#! /bin/sh /usr/share/dpatch/dpatch-run
## opt-27_ttxtsubs.dpatch from the vdr-ttxtsubs plug-in version 0.1.0
##
##   - adapted to dd-record-option patch (UseDolbyDigital -> RecordDolbyDigital)
##
## Thomas Günther <tom@toms-cafe.de>:
##   - adapted to VDR-1.7.8
##   - adapted to VDR-1.7.9
##   - adapted to VDR-1.7.10
##   - adapted to VDR-1.7.11
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: This patch is needed for the ttxtsubs plugin.

@DPATCH@
diff -Naurp vdr-1.7.11/Makefile vdr-1.7.11-ttxtsubs/Makefile
--- vdr-1.7.11/Makefile	2009-12-29 11:20:50.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/Makefile	2010-01-07 15:07:58.000000000 +0000
@@ -43,6 +43,8 @@ OBJS = audio.o channels.o ci.o config.o 
        skinclassic.o skins.o skinsttng.o sources.o spu.o status.o svdrp.o themes.o thread.o\
        timers.o tools.o transfer.o vdr.o videodir.o
 
+OBJS += vdrttxtsubshooks.o
+
 ifndef NO_KBD
 DEFINES += -DREMOTE_KBD
 endif
diff -Naurp vdr-1.7.11/channels.c vdr-1.7.11-ttxtsubs/channels.c
--- vdr-1.7.11/channels.c	2010-01-02 17:38:40.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/channels.c	2010-01-07 15:07:58.000000000 +0000
@@ -551,6 +551,15 @@ void cChannel::SetSubtitlingDescriptors(
      }
 }
 
+void cChannel::SetTPidData(char TLangs[][MAXLANGCODE2], int TPages[])
+{
+  for (int i = 0; i < MAXTPAGES; i++) {
+      tpages[i] = TPages[i];
+      strn0cpy(tlangs[i], TLangs[i], MAXLANGCODE2);
+      }
+  tpages[MAXTPAGES] = 0;
+}
+
 void cChannel::SetCaIds(const int *CaIds)
 {
   if (caids[0] && caids[0] <= CA_USER_MAX)
diff -Naurp vdr-1.7.11/channels.h vdr-1.7.11-ttxtsubs/channels.h
--- vdr-1.7.11/channels.h	2009-12-06 12:57:45.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/channels.h	2010-01-07 15:07:58.000000000 +0000
@@ -35,6 +35,7 @@
 #define MAXDPIDS 16 // dolby (AC3 + DTS)
 #define MAXSPIDS 32 // subtitles
 #define MAXCAIDS  8 // conditional access
+#define MAXTPAGES 8 // teletext pages
 
 #define MAXLANGCODE1 4 // a 3 letter language code, zero terminated
 #define MAXLANGCODE2 8 // up to two 3 letter language codes, separated by '+' and zero terminated
@@ -133,6 +134,8 @@ private:
   uint16_t compositionPageIds[MAXSPIDS];
   uint16_t ancillaryPageIds[MAXSPIDS];
   int tpid;
+  char tlangs[MAXTPAGES][MAXLANGCODE2];
+  int tpages[MAXTPAGES + 1]; // list is zero-terminated
   int caids[MAXCAIDS + 1]; // list is zero-terminated
   int nid;
   int tid;
@@ -192,6 +195,8 @@ public:
   uint16_t CompositionPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? compositionPageIds[i] : uint16_t(0); }
   uint16_t AncillaryPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? ancillaryPageIds[i] : uint16_t(0); }
   int Tpid(void) const { return tpid; }
+  const char *Tlang(int i) const { return (0 <= i && i < MAXTPAGES) ? tlangs[i] : ""; }
+  const int TPages(int i) const { return (0 <= i && i < MAXTPAGES) ? tpages[i] : 0; }
   const int *Caids(void) const { return caids; }
   int Ca(int Index = 0) const { return Index < MAXCAIDS ? caids[Index] : 0; }
   int Nid(void) const { return nid; }
@@ -228,6 +233,7 @@ public:
   void SetName(const char *Name, const char *ShortName, const char *Provider);
   void SetPortalName(const char *PortalName);
   void SetPids(int Vpid, int Ppid, int Vtype, int *Apids, char ALangs[][MAXLANGCODE2], int *Dpids, char DLangs[][MAXLANGCODE2], int *Spids, char SLangs[][MAXLANGCODE2], int Tpid);
+  void SetTPidData(char TLangs[][MAXLANGCODE2], int TPages[]);
   void SetCaIds(const int *CaIds); // list must be zero-terminated
   void SetCaDescriptors(int Level);
   void SetLinkChannels(cLinkChannels *LinkChannels);
diff -Naurp vdr-1.7.11/device.c vdr-1.7.11-ttxtsubs/device.c
--- vdr-1.7.11/device.c	2010-01-01 15:40:35.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/device.c	2010-01-07 15:07:58.000000000 +0000
@@ -18,6 +18,7 @@
 #include "receiver.h"
 #include "status.h"
 #include "transfer.h"
+#include "vdrttxtsubshooks.h"
 
 // --- cLiveSubtitle ---------------------------------------------------------
 
@@ -1190,6 +1191,13 @@ int cDevice::PlayPesPacket(const uchar *
                   }
                break;
           case 0xBD: { // private stream 1
+               // EBU Teletext data, ETSI EN 300 472
+               // if PES data header length = 24 and data_identifier = 0x10..0x1F (EBU Data)
+               if (Data[8] == 0x24 && Data[45] >= 0x10 && Data[45] < 0x20) {
+                  cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uint8_t*)Data, Length);
+                  break;
+                  }
+
                int PayloadOffset = Data[8] + 9;
 
                // Compatibility mode for old subtitles plugin:
@@ -1349,6 +1357,7 @@ int cDevice::PlayTs(const uchar *Data, i
      tsToPesVideo.Reset();
      tsToPesAudio.Reset();
      tsToPesSubtitle.Reset();
+     tsToPesTeletext.Reset();
      }
   else if (Length < TS_SIZE) {
      esyslog("ERROR: skipped %d bytes of TS fragment", Length);
@@ -1394,6 +1403,17 @@ int cDevice::PlayTs(const uchar *Data, i
                     if (!VideoOnly || HasIBPTrickSpeed())
                        PlayTsSubtitle(Data, TS_SIZE);
                     }
+                 else if (Pid == patPmtParser.Tpid()) {
+                    if (!VideoOnly || HasIBPTrickSpeed()) {
+                       int l;
+                       tsToPesTeletext.PutTs(Data, Length);
+                       if (const uchar *p = tsToPesTeletext.GetPes(l)) {
+                          if ((l > 45) && (p[0] == 0x00) && (p[1] == 0x00) && (p[2] == 0x01) && (p[3] == 0xbd) && (p[8] == 0x24) && (p[45] >= 0x10) && (p[45] < 0x20))
+                             cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uchar *)p, l, false);
+                          tsToPesTeletext.Reset();
+                          }
+                       }
+                    }
                  }
               }
            Played += TS_SIZE;
diff -Naurp vdr-1.7.11/device.h vdr-1.7.11-ttxtsubs/device.h
--- vdr-1.7.11/device.h	2010-01-01 15:04:27.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/device.h	2010-01-07 15:07:58.000000000 +0000
@@ -499,6 +499,7 @@ private:
   cTsToPes tsToPesVideo;
   cTsToPes tsToPesAudio;
   cTsToPes tsToPesSubtitle;
+  cTsToPes tsToPesTeletext;
   bool isPlayingVideo;
 protected:
   const cPatPmtParser *PatPmtParser(void) const { return &patPmtParser; }
diff -Naurp vdr-1.7.11/menu.c vdr-1.7.11-ttxtsubs/menu.c
--- vdr-1.7.11/menu.c	2009-12-06 11:29:05.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/menu.c	2010-01-07 15:07:58.000000000 +0000
@@ -3759,7 +3759,8 @@ cRecordControl::cRecordControl(cDevice *
   isyslog("record %s", fileName);
   if (MakeDirs(fileName, true)) {
      const cChannel *ch = timer->Channel();
-     recorder = new cRecorder(fileName, ch->GetChannelID(), timer->Priority(), ch->Vpid(), ch->Apids(), ch->Dpids(), ch->Spids());
+     int TPid[2] = { ch->Tpid(), 0 };
+     recorder = new cRecorder(fileName, ch->GetChannelID(), timer->Priority(), ch->Vpid(), ch->Apids(), ch->Dpids(), ch->Spids(), TPid);
      if (device->AttachReceiver(recorder)) {
         Recording.WriteInfo();
         cStatus::MsgRecording(device, Recording.Name(), Recording.FileName(), true);
diff -Naurp vdr-1.7.11/pat.c vdr-1.7.11-ttxtsubs/pat.c
--- vdr-1.7.11/pat.c	2010-01-01 15:40:05.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/pat.c	2010-01-07 15:07:58.000000000 +0000
@@ -13,6 +13,7 @@
 #include "libsi/section.h"
 #include "libsi/descriptor.h"
 #include "thread.h"
+#include "vdrttxtsubshooks.h"
 
 #define PMT_SCAN_TIMEOUT  10 // seconds
 
@@ -341,6 +342,9 @@ void cPatFilter::Process(u_short Pid, u_
         char DLangs[MAXDPIDS][MAXLANGCODE2] = { "" };
         char SLangs[MAXSPIDS][MAXLANGCODE2] = { "" };
         int Tpid = 0;
+        char TLangs[MAXTPAGES][MAXLANGCODE2] = { "" };
+        int TPages[MAXTPAGES + 1] = { 0 };
+        int NumTPages = 0;
         int NumApids = 0;
         int NumDpids = 0;
         int NumSpids = 0;
@@ -426,8 +430,19 @@ void cPatFilter::Process(u_short Pid, u_
                                     NumSpids++;
                                     }
                                  break;
-                            case SI::TeletextDescriptorTag:
+                            case SI::TeletextDescriptorTag: {
                                  Tpid = esPid;
+                                 SI::TeletextDescriptor *sd = (SI::TeletextDescriptor *)d;
+                                 SI::TeletextDescriptor::Teletext ttxt;
+                                 for (SI::Loop::Iterator it; sd->teletextLoop.getNext(ttxt, it); ) {
+                                     if ((NumTPages < MAXTPAGES) && ttxt.languageCode[0] && ((ttxt.getTeletextType() == 0x02) || (ttxt.getTeletextType() == 0x05))) {
+                                        char *s = TLangs[NumTPages];
+                                        strn0cpy(s, I18nNormalizeLanguageCode(ttxt.languageCode), MAXLANGCODE1);
+                                        TPages[NumTPages] = (ttxt.getTeletextPageNumber() & 0xff) | ((ttxt.getTeletextMagazineNumber() & 0xff) << 8) | ((ttxt.getTeletextType() & 0xff) << 16);
+                                        NumTPages++;
+                                        }
+                                     }
+                                 }
                                  break;
                             case SI::ISO639LanguageDescriptorTag: {
                                  SI::ISO639LanguageDescriptor *ld = (SI::ISO639LanguageDescriptor *)d;
@@ -458,6 +473,16 @@ void cPatFilter::Process(u_short Pid, u_
             }
         if (Setup.UpdateChannels >= 2) {
            Channel->SetPids(Vpid, Ppid, Vtype, Apids, ALangs, Dpids, DLangs, Spids, SLangs, Tpid);
+           if (NumTPages < MAXTPAGES) {
+              int manualPageNumber = cVDRTtxtsubsHookListener::Hook()->ManualPageNumber(Channel);
+              if (manualPageNumber) {
+                 char *s = TLangs[NumTPages];
+                 strn0cpy(s, "man", MAXLANGCODE1);
+                 TPages[NumTPages] = manualPageNumber;
+                 NumTPages++;
+                 }
+              }
+           Channel->SetTPidData(TLangs, TPages);
            Channel->SetCaIds(CaDescriptors->CaIds());
            Channel->SetSubtitlingDescriptors(SubtitlingTypes, CompositionPageIds, AncillaryPageIds);
            }
diff -Naurp vdr-1.7.11/receiver.c vdr-1.7.11-ttxtsubs/receiver.c
--- vdr-1.7.11/receiver.c	2010-01-01 15:38:48.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/receiver.c	2010-01-07 15:07:58.000000000 +0000
@@ -12,7 +12,7 @@
 #include <stdio.h>
 #include "tools.h"
 
-cReceiver::cReceiver(tChannelID ChannelID, int Priority, int Pid, const int *Pids1, const int *Pids2, const int *Pids3)
+cReceiver::cReceiver(tChannelID ChannelID, int Priority, int Pid, const int *Pids1, const int *Pids2, const int *Pids3, const int *Pids4)
 {
   device = NULL;
   channelID = ChannelID;
@@ -32,6 +32,10 @@ cReceiver::cReceiver(tChannelID ChannelI
      while (*Pids3 && numPids < MAXRECEIVEPIDS)
            pids[numPids++] = *Pids3++;
      }
+  if (Pids4) {
+     while (*Pids4 && numPids < MAXRECEIVEPIDS)
+           pids[numPids++] = *Pids4++;
+     }
   if (numPids >= MAXRECEIVEPIDS)
      dsyslog("too many PIDs in cReceiver");
 }
diff -Naurp vdr-1.7.11/receiver.h vdr-1.7.11-ttxtsubs/receiver.h
--- vdr-1.7.11/receiver.h	2007-01-05 11:00:36.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/receiver.h	2010-01-07 15:07:58.000000000 +0000
@@ -38,10 +38,10 @@ protected:
                ///< will be delivered only ONCE, so the cReceiver must make sure that
                ///< it will be able to buffer the data if necessary.
 public:
-  cReceiver(tChannelID ChannelID, int Priority, int Pid, const int *Pids1 = NULL, const int *Pids2 = NULL, const int *Pids3 = NULL);
+  cReceiver(tChannelID ChannelID, int Priority, int Pid, const int *Pids1 = NULL, const int *Pids2 = NULL, const int *Pids3 = NULL, const int *Pids4 = NULL);
                ///< Creates a new receiver for the channel with the given ChannelID with
                ///< the given Priority. Pid is a single PID (typically the video PID), while
-               ///< Pids1...Pids3 are pointers to zero terminated lists of PIDs.
+               ///< Pids1...Pids4 are pointers to zero terminated lists of PIDs.
                ///< If any of these PIDs are 0, they will be silently ignored.
                ///< The total number of non-zero PIDs must not exceed MAXRECEIVEPIDS.
                ///< Priority may be any value in the range -99..99. Negative values indicate
diff -Naurp vdr-1.7.11/recorder.c vdr-1.7.11-ttxtsubs/recorder.c
--- vdr-1.7.11/recorder.c	2009-12-06 11:34:41.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/recorder.c	2010-01-07 15:07:58.000000000 +0000
@@ -21,8 +21,8 @@
 
 // --- cRecorder -------------------------------------------------------------
 
-cRecorder::cRecorder(const char *FileName, tChannelID ChannelID, int Priority, int VPid, const int *APids, const int *DPids, const int *SPids)
-:cReceiver(ChannelID, Priority, VPid, APids, Setup.RecordDolbyDigital ? DPids : NULL, SPids)
+cRecorder::cRecorder(const char *FileName, tChannelID ChannelID, int Priority, int VPid, const int *APids, const int *DPids, const int *SPids, const int *EPids)
+:cReceiver(ChannelID, Priority, VPid, APids, Setup.RecordDolbyDigital ? DPids : NULL, SPids, EPids)
 ,cThread("recording")
 ,recordingInfo(FileName)
 {
diff -Naurp vdr-1.7.11/recorder.h vdr-1.7.11-ttxtsubs/recorder.h
--- vdr-1.7.11/recorder.h	2009-01-06 10:44:58.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/recorder.h	2010-01-07 15:07:58.000000000 +0000
@@ -34,7 +34,7 @@ protected:
   virtual void Receive(uchar *Data, int Length);
   virtual void Action(void);
 public:
-  cRecorder(const char *FileName, tChannelID ChannelID, int Priority, int VPid, const int *APids, const int *DPids, const int *SPids);
+  cRecorder(const char *FileName, tChannelID ChannelID, int Priority, int VPid, const int *APids, const int *DPids, const int *SPids, const int *EPids = NULL);
                // Creates a new recorder for the channel with the given ChannelID and
                // the given Priority that will record the given PIDs into the file FileName.
   virtual ~cRecorder();
diff -Naurp vdr-1.7.11/remux.c vdr-1.7.11-ttxtsubs/remux.c
--- vdr-1.7.11/remux.c	2009-12-29 15:56:33.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/remux.c	2010-01-07 23:38:29.000000000 +0000
@@ -215,6 +215,30 @@ int cPatPmtGenerator::MakeSubtitlingDesc
   return i;
 }
 
+int cPatPmtGenerator::MakeTeletextDescriptor(uchar *Target, cChannel *Channel)
+{
+  int i = 0, j = 0;
+  Target[i++] = SI::TeletextDescriptorTag;
+  int l = i;
+  Target[i++] = 0x00; // length
+  for (int n = 0; Channel->TPages(n); n++) {
+      const char *Language = Channel->Tlang(n);
+      int Pages = Channel->TPages(n);
+      Target[i++] = *Language++;
+      Target[i++] = *Language++;
+      Target[i++] = *Language++;
+      Target[i++] = ((Pages >> 13) & 0xf8) | ((Pages >> 8) & 0x7); // teletext type & magazine number
+      Target[i++] = Pages & 0xff; // teletext page number
+      j++;
+      }
+  if (j > 0) {
+     Target[l] = j * 5; // update length
+     IncEsInfoLength(i);
+     return i;
+     }
+  return 0;
+}
+
 int cPatPmtGenerator::MakeLanguageDescriptor(uchar *Target, const char *Language)
 {
   int i = 0;
@@ -296,6 +320,7 @@ void cPatPmtGenerator::GeneratePmt(cChan
   if (Channel) {
      int Vpid = Channel->Vpid();
      int Ppid = 0x1FFF; // no PCR pid
+     int Tpid = Channel->Tpid();
      uchar *p = buf;
      int i = 0;
      p[i++] = 0x02; // table id
@@ -330,6 +355,10 @@ void cPatPmtGenerator::GeneratePmt(cChan
          i += MakeStream(buf + i, 0x06, Channel->Spid(n));
          i += MakeSubtitlingDescriptor(buf + i, Channel->Slang(n), Channel->SubtitlingType(n), Channel->CompositionPageId(n), Channel->AncillaryPageId(n));
          }
+     if (Tpid) {
+        i += MakeStream(buf + i, 0x06, Tpid);
+        i += MakeTeletextDescriptor(buf + i, Channel);
+        }
 
      int sl = i - SectionLength - 2 + 4; // -2 = SectionLength storage, +4 = length of CRC
      buf[SectionLength] |= (sl >> 8) & 0x0F;
@@ -402,6 +431,7 @@ void cPatPmtParser::Reset(void)
   patVersion = pmtVersion = -1;
   pmtPid = -1;
   vpid = vtype = 0;
+  tpid = 0;
 }
 
 void cPatPmtParser::ParsePat(const uchar *Data, int Length)
@@ -491,6 +521,7 @@ void cPatPmtParser::ParsePmt(const uchar
      spids[0] = 0;
      atypes[0] = 0;
      dtypes[0] = 0;
+     tpid = 0;
      SI::PMT::Stream stream;
      for (SI::Loop::Iterator it; Pmt.streamLoop.getNext(stream, it); ) {
          dbgpatpmt("     stream type = %02X, pid = %d", stream.getStreamType(), stream.getPid());
@@ -583,6 +614,10 @@ void cPatPmtParser::ParsePmt(const uchar
                                     spids[NumSpids]= 0;
                                     }
                                  break;
+                            case SI::TeletextDescriptorTag:
+                                 dbgpatpmt(" teletext");
+                                 tpid = stream.getPid();
+                                 break;
                             case SI::ISO639LanguageDescriptorTag: {
                                  SI::ISO639LanguageDescriptor *ld = (SI::ISO639LanguageDescriptor *)d;
                                  dbgpatpmt(" '%s'", ld->languageCode);
diff -Naurp vdr-1.7.11/remux.h vdr-1.7.11-ttxtsubs/remux.h
--- vdr-1.7.11/remux.h	2009-12-29 15:53:54.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/remux.h	2010-01-07 23:34:55.000000000 +0000
@@ -170,6 +170,7 @@ protected:
   int MakeStream(uchar *Target, uchar Type, int Pid);
   int MakeAC3Descriptor(uchar *Target);
   int MakeSubtitlingDescriptor(uchar *Target, const char *Language, uchar SubtitlingType, uint16_t CompositionPageId, uint16_t AncillaryPageId);
+  int MakeTeletextDescriptor(uchar *Target, cChannel *Channel);
   int MakeLanguageDescriptor(uchar *Target, const char *Language);
   int MakeCRC(uchar *Target, const uchar *Data, int Length);
   void GeneratePmtPid(cChannel *Channel);
@@ -226,6 +227,7 @@ private:
   uint16_t compositionPageIds[MAXSPIDS];
   uint16_t ancillaryPageIds[MAXSPIDS];
   bool updatePrimaryDevice;
+  int tpid;
 protected:
   int SectionLength(const uchar *Data, int Length) { return (Length >= 3) ? ((int(Data[1]) & 0x0F) << 8)| Data[2] : 0; }
 public:
@@ -269,6 +271,7 @@ public:
   uchar SubtitlingType(int i) const { return (0 <= i && i < MAXSPIDS) ? subtitlingTypes[i] : uchar(0); }
   uint16_t CompositionPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? compositionPageIds[i] : uint16_t(0); }
   uint16_t AncillaryPageId(int i) const { return (0 <= i && i < MAXSPIDS) ? ancillaryPageIds[i] : uint16_t(0); }
+  int Tpid(void) { return tpid; }
   };
 
 // TS to PES converter:
diff -Naurp vdr-1.7.11/vdrttxtsubshooks.c vdr-1.7.11-ttxtsubs/vdrttxtsubshooks.c
--- vdr-1.7.11/vdrttxtsubshooks.c	1970-01-01 00:00:00.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/vdrttxtsubshooks.c	2010-01-07 15:07:59.000000000 +0000
@@ -0,0 +1,63 @@
+/*
+ * vdr-ttxtsubs - A plugin for the Linux Video Disk Recorder
+ * Copyright (c) 2003 - 2008 Ragnar Sundblad <ragge@nada.kth.se>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+
+#include "vdrttxtsubshooks.h"
+
+// XXX Really should be a list...
+static cVDRTtxtsubsHookListener *gListener;
+
+// ------ class cVDRTtxtsubsHookProxy ------
+
+class cVDRTtxtsubsHookProxy : public cVDRTtxtsubsHookListener
+{
+ public:
+  virtual void HideOSD(void) { if(gListener) gListener->HideOSD(); };
+  virtual void ShowOSD(void) { if(gListener) gListener->ShowOSD(); };
+  virtual void PlayerTeletextData(uint8_t *p, int length, bool IsPesRecording)
+    { if(gListener) gListener->PlayerTeletextData(p, length, IsPesRecording); };
+  virtual int ManualPageNumber(const cChannel *channel)
+    { if(gListener) return gListener->ManualPageNumber(channel); else return 0; };
+};
+
+
+// ------ class cVDRTtxtsubsHookListener ------
+
+cVDRTtxtsubsHookListener::~cVDRTtxtsubsHookListener()
+{
+  gListener = 0;
+}
+
+void cVDRTtxtsubsHookListener::HookAttach(void)
+{
+  gListener = this;
+  //printf("cVDRTtxtsubsHookListener::HookAttach\n");
+}
+
+static cVDRTtxtsubsHookProxy gProxy;
+
+cVDRTtxtsubsHookListener *cVDRTtxtsubsHookListener::Hook(void)
+{
+  return &gProxy;
+}
+
diff -Naurp vdr-1.7.11/vdrttxtsubshooks.h vdr-1.7.11-ttxtsubs/vdrttxtsubshooks.h
--- vdr-1.7.11/vdrttxtsubshooks.h	1970-01-01 00:00:00.000000000 +0000
+++ vdr-1.7.11-ttxtsubs/vdrttxtsubshooks.h	2010-01-07 15:07:59.000000000 +0000
@@ -0,0 +1,48 @@
+/*
+ * vdr-ttxtsubs - A plugin for the Linux Video Disk Recorder
+ * Copyright (c) 2003 - 2008 Ragnar Sundblad <ragge@nada.kth.se>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef __VDRTTXTSUBSHOOKS_H
+#define __VDRTTXTSUBSHOOKS_H
+
+#define TTXTSUBSVERSNUM 1
+
+class cDevice;
+class cChannel;
+
+#define VDRTTXTSUBSHOOKS
+
+class cVDRTtxtsubsHookListener {
+ public:
+  cVDRTtxtsubsHookListener(void) {};
+  virtual ~cVDRTtxtsubsHookListener();
+
+  void HookAttach(void);
+
+  virtual void HideOSD(void) {};
+  virtual void ShowOSD(void) {};
+  virtual void PlayerTeletextData(uint8_t *p, int length, bool IsPesRecording = true) {};
+  virtual int ManualPageNumber(const cChannel *channel)
+    { return 0; };
+
+  // used by VDR to call hook listeners
+  static cVDRTtxtsubsHookListener *Hook(void);
+};
+
+#endif
