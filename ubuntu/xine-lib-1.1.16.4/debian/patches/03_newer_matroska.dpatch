#! /bin/sh /usr/share/dpatch/dpatch-run
## 03_newer_matroska.dpatch by  <root@fluffybitch.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Add newer Matroska container version support to libxine-1.1.16

@DPATCH@

diff -Nru xine-lib-1.1.16.4-orig/src/demuxers/demux_matroska.c xine-lib-1.1.16.4-lmce0/src/demuxers/demux_matroska.c
--- xine-lib-1.1.16.4-orig/src/demuxers/demux_matroska.c	2010-07-20 16:52:59.000000000 +0000
+++ xine-lib-1.1.16.4-lmce0/src/demuxers/demux_matroska.c	2010-07-21 12:33:23.000000000 +0000
@@ -1,18 +1,18 @@
 /*
  * Copyright (C) 2000-2008 the xine project
- * 
+ *
  * This file is part of xine, a free video player.
- * 
+ *
  * xine is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * xine is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
@@ -42,6 +42,7 @@
 /*
 #define LOG
 */
+
 #include "xine_internal.h"
 #include "xineutils.h"
 #include "demux.h"
@@ -50,89 +51,7 @@
 
 #include "ebml.h"
 #include "matroska.h"
-
-#define NUM_PREVIEW_BUFFERS      10
-
-#define MAX_STREAMS             128
-#define MAX_FRAMES               32
-
-#define WRAP_THRESHOLD        90000
-
-typedef struct {
-  int                  track_num;
-  off_t               *pos;
-  uint64_t            *timecode;
-  int                  num_entries;
-  
-} matroska_index_t;
-
-typedef struct {
-
-  demux_plugin_t       demux_plugin;
-
-  xine_stream_t       *stream;
-
-  input_plugin_t      *input;
-
-  int                  status;
-
-  ebml_parser_t       *ebml;
-
-  /* segment element */
-  ebml_elem_t          segment;
-  uint64_t             timecode_scale;
-  int                  duration;            /* in millis */
-  int                  preview_sent;
-  int                  preview_mode;
-
-  /* meta seek info */
-  int                  has_seekhead;
-  int                  seekhead_handled;
-
-  /* seek info */
-  matroska_index_t    *indexes;
-  int                  num_indexes;
-  int                  first_cluster_found;
-  int                  skip_to_timecode;
-  int                  skip_for_track;
-
-  /* tracks */
-  int                  num_tracks;
-  int                  num_video_tracks;
-  int                  num_audio_tracks;
-  int                  num_sub_tracks;
-
-  matroska_track_t    *tracks[MAX_STREAMS];
-
-  /* block */
-  uint8_t             *block_data;
-  size_t               block_data_size;
-
-  /* current tracks */
-  matroska_track_t    *video_track;   /* to remove */
-  matroska_track_t    *audio_track;   /* to remove */
-  matroska_track_t    *sub_track;     /* to remove */
-  
-  int                  send_newpts;
-  int                  buf_flag_seek;
-  
-  /* seekhead parsing */
-  int                  top_level_list_size;
-  int                  top_level_list_max_size;
-  off_t               *top_level_list;
-
-} demux_matroska_t ;
-
-typedef struct {
-
-  demux_class_t     demux_class;
-
-  /* class-wide, global variables here */
-
-  xine_t           *xine;
-
-} demux_matroska_class_t;
-
+#include "demux_matroska.h"
 
 static void check_newpts (demux_matroska_t *this, int64_t pts,
                           matroska_track_t *track) {
@@ -140,7 +59,7 @@
 
   if ((track->track_type == MATROSKA_TRACK_VIDEO) ||
       (track->track_type == MATROSKA_TRACK_AUDIO)) {
-  
+
     diff = pts - track->last_pts;
 
     if (pts && (this->send_newpts || (track->last_pts && abs(diff)>WRAP_THRESHOLD)) ) {
@@ -206,10 +125,10 @@
   ebml_parser_t *ebml = this->ebml;
   int next_level = 2;
   double duration = 0.0; /* in matroska unit */
-  
+
   while (next_level == 2) {
     ebml_elem_t elem;
-    
+
     if (!ebml_read_elem_head(ebml, &elem))
       return 0;
 
@@ -219,14 +138,22 @@
         if (!ebml_read_uint(ebml, &elem, &this->timecode_scale))
           return 0;
         break;
-      case MATROSKA_ID_I_DURATION: {
-        
+
+      case MATROSKA_ID_I_DURATION:
         lprintf("duration\n");
         if (!ebml_read_float(ebml, &elem, &duration))
           return 0;
-      }
-      break;
-      
+        break;
+
+      case MATROSKA_ID_I_TITLE:
+        lprintf("title\n");
+        if (NULL != this->title)
+          free(this->title);
+
+        this->title = ebml_alloc_read_ascii(ebml, &elem);
+        _x_meta_info_set_utf8(this->stream, XINE_META_INFO_TITLE, this->title);
+        break;
+
       default:
         lprintf("Unhandled ID: 0x%x\n", elem.id);
         if (!ebml_skip(ebml, &elem))
@@ -240,6 +167,8 @@
   this->duration = (int)(duration * (double)this->timecode_scale / 1000000.0);
   lprintf("timecode_scale: %" PRId64 "\n", this->timecode_scale);
   lprintf("duration: %d\n", this->duration);
+  lprintf("title: %s\n", (NULL != this->title ? this->title : "(none)"));
+
   return 1;
 }
 
@@ -481,9 +410,9 @@
 
 static void init_codec_video(demux_matroska_t *this, matroska_track_t *track) {
   buf_element_t *buf;
-  
+
   buf = track->fifo->buffer_pool_alloc (track->fifo);
-  
+
   if (track->codec_private_len > buf->max_size) {
     xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
             "demux_matroska: private decoder data length (%d) is greater than fifo buffer length (%" PRId32 ")\n",
@@ -500,20 +429,20 @@
     xine_fast_memcpy (buf->content, track->codec_private, buf->size);
   else
     buf->content = NULL;
-  
+
   if(track->default_duration) {
     buf->decoder_flags   |= BUF_FLAG_FRAMERATE;
-    buf->decoder_info[0]  = (int64_t)track->default_duration * 
+    buf->decoder_info[0]  = (int64_t)track->default_duration *
                             (int64_t)90 / (int64_t)1000000;
   }
-  
-  if(track->video_track && track->video_track->display_width && 
+
+  if(track->video_track && track->video_track->display_width &&
      track->video_track->display_height) {
     buf->decoder_flags   |= BUF_FLAG_ASPECT;
     buf->decoder_info[1]  = track->video_track->display_width;
     buf->decoder_info[2]  = track->video_track->display_height;
   }
-    
+
   track->fifo->put (track->fifo, buf);
 }
 
@@ -531,7 +460,7 @@
     return;
   }
   buf->size = track->codec_private_len;
-  
+
   /* default param */
   buf->decoder_info[0] = 0;
   buf->decoder_info[1] = 44100;
@@ -563,9 +492,9 @@
 
 static void init_codec_real(demux_matroska_t *this, matroska_track_t * track) {
   buf_element_t *buf;
-  
+
   buf = track->fifo->buffer_pool_alloc (track->fifo);
-  
+
   if (track->codec_private_len > buf->max_size) {
     xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
             "demux_matroska: private decoder data length (%d) is greater than fifo buffer length (%" PRId32 ")\n",
@@ -573,30 +502,30 @@
     buf->free_buffer(buf);
     return;
   }
-  
+
   buf->size          = track->codec_private_len;
   buf->decoder_flags = BUF_FLAG_HEADER | BUF_FLAG_FRAME_END;
   buf->type          = track->buf_type;
   buf->pts           = 0;
-    
+
   if (buf->size)
     xine_fast_memcpy (buf->content, track->codec_private, buf->size);
   else
     buf->content = NULL;
-  
+
   if(track->default_duration) {
     buf->decoder_flags   |= BUF_FLAG_FRAMERATE;
-    buf->decoder_info[0]  = (int64_t)track->default_duration * 
+    buf->decoder_info[0]  = (int64_t)track->default_duration *
                             (int64_t)90 / (int64_t)1000000;
   }
-  
-  if(track->video_track && track->video_track->display_width && 
+
+  if(track->video_track && track->video_track->display_width &&
      track->video_track->display_height) {
     buf->decoder_flags   |= BUF_FLAG_ASPECT;
     buf->decoder_info[1]  = track->video_track->display_width;
     buf->decoder_info[2]  = track->video_track->display_height;
   }
-    
+
   track->fifo->put (track->fifo, buf);
 }
 
@@ -607,6 +536,8 @@
   int i;
   uint8_t *data;
 
+  if (track->codec_private_len < 3)
+    return;
   nb_lace = track->codec_private[0];
   if (nb_lace != 2)
     return;
@@ -614,11 +545,13 @@
   frame[0] = track->codec_private[1];
   frame[1] = track->codec_private[2];
   frame[2] = track->codec_private_len - frame[0] - frame[1] - 3;
+  if (frame[2] < 0)
+    return;
 
   data = track->codec_private + 3;
   for (i = 0; i < 3; i++) {
     buf = track->fifo->buffer_pool_alloc (track->fifo);
-    
+
     if (frame[i] > buf->max_size) {
       xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
               "demux_matroska: private decoder data length (%d) is greater than fifo buffer length (%" PRId32 ")\n",
@@ -627,7 +560,7 @@
       return;
     }
     buf->size = frame[i];
-    
+
     buf->decoder_flags = BUF_FLAG_HEADER | BUF_FLAG_FRAME_START | BUF_FLAG_FRAME_END;
     buf->type          = track->buf_type;
     buf->pts           = 0;
@@ -916,7 +849,7 @@
     buf->decoder_info[1] = BUF_SPECIAL_RV_CHUNK_TABLE;
     buf->decoder_info[2] = chunks;
     buf->decoder_info_ptr[2] = buf->content;
-    
+
     buf->size = 0;
     buf->type = track->buf_type;
 
@@ -983,7 +916,7 @@
         }
       }
     }
-    
+
     last_char = *data;
     data++; data_len--;
   }
@@ -994,11 +927,11 @@
     buf->size = dest - (char *)buf->content;
     buf->extra_info->input_normpos = input_normpos;
     buf->extra_info->input_time    = input_time;
-  
+
     track->fifo->put(track->fifo, buf);
   } else {
     buf->free_buffer(buf);
-  }                            
+  }
 }
 
 static void handle_sub_utf8 (demux_plugin_t *this_gen, matroska_track_t *track,
@@ -1013,7 +946,7 @@
   buf = track->fifo->buffer_pool_alloc(track->fifo);
 
   buf->size = data_len + 9;  /* 2 uint32_t + '\0' */
-  
+
   if (buf->max_size >= buf->size) {
 
     buf->decoder_flags = decoder_flags;
@@ -1022,7 +955,7 @@
     buf->decoder_info[1] = BUF_SPECIAL_CHARSET_ENCODING;
     buf->decoder_info_ptr[2] = "utf-8";
     buf->decoder_info[2] = strlen(buf->decoder_info_ptr[2]);
-    
+
     val = (uint32_t *)buf->content;
     *val++ = data_pts / 90;                    /* start time */
     *val++ = (data_pts + data_duration) / 90;  /* end time   */
@@ -1087,7 +1020,7 @@
                 (int)track->track_num, result);
         free(dest);
         inflateEnd(&zstream);
-       
+
         if (result == Z_DATA_ERROR && track->compress_algo == MATROSKA_COMPRESS_UNKNOWN) {
           track->compress_algo = MATROSKA_COMPRESS_NONE;
           data_len = old_data_len;
@@ -1100,11 +1033,11 @@
       zstream.avail_out += 4000;
     } while ((zstream.avail_out == 4000) &&
             (zstream.avail_in != 0) && (result != Z_STREAM_END));
- 
+
     if (track->compress_algo != MATROSKA_COMPRESS_NONE) {
       data_len = zstream.total_out;
       inflateEnd(&zstream);
- 
+
       data = dest;
       track->compress_algo = MATROSKA_COMPRESS_ZLIB;
       lprintf("VobSub: decompression for track %d from %d to %d\n",
@@ -1147,62 +1080,72 @@
 static int parse_track_entry(demux_matroska_t *this, matroska_track_t *track) {
   ebml_parser_t *ebml = this->ebml;
   int next_level = 3;
-  
+
   while (next_level == 3) {
     ebml_elem_t elem;
-    
+
     if (!ebml_read_elem_head(ebml, &elem))
       return 0;
 
     switch (elem.id) {
-      case MATROSKA_ID_TR_NUMBER: {
-        uint64_t num;
-        lprintf("TrackNumber\n");
-        if (!ebml_read_uint(ebml, &elem, &num))
-          return 0;
-        track->track_num = num;
-      }
-      break;
-      
-      case MATROSKA_ID_TR_TYPE: {
-        uint64_t num;
-        lprintf("TrackType\n");
-        if (!ebml_read_uint(ebml, &elem, &num))
-          return 0;
-        track->track_type = num;
-      }
-      break;
-      
-      case MATROSKA_ID_TR_CODECID: {
-        char *codec_id = ebml_alloc_read_ascii (ebml, &elem);
-        lprintf("CodecID\n");
-        if (!codec_id)
-          return 0;
-        track->codec_id = codec_id;
-      }
-      break;
-        
-      case MATROSKA_ID_TR_CODECPRIVATE: {
-        char *codec_private = malloc (elem.len);
-        lprintf("CodecPrivate\n");
-        if (!ebml_read_binary(ebml, &elem, codec_private)) {
-	  free(codec_private);
-          return 0;
-	}
-        track->codec_private = codec_private;
-        track->codec_private_len = elem.len;
-      }
-      break;
-        
-      case MATROSKA_ID_TR_LANGUAGE: {
-        char *language = ebml_alloc_read_ascii (ebml, &elem);
-        lprintf("Language\n");
-        if (!language)
-          return 0;
-        track->language = language;
-      }
-      break;
-      
+      case MATROSKA_ID_TR_NUMBER:
+        {
+          uint64_t num;
+          lprintf("TrackNumber\n");
+          if (!ebml_read_uint(ebml, &elem, &num))
+            return 0;
+          track->track_num = num;
+        }
+        break;
+
+      case MATROSKA_ID_TR_TYPE:
+        {
+          uint64_t num;
+          lprintf("TrackType\n");
+          if (!ebml_read_uint(ebml, &elem, &num))
+            return 0;
+          track->track_type = num;
+        }
+        break;
+
+      case MATROSKA_ID_TR_CODECID:
+        {
+          char *codec_id = ebml_alloc_read_ascii (ebml, &elem);
+          lprintf("CodecID\n");
+          if (!codec_id)
+            return 0;
+          track->codec_id = codec_id;
+        }
+        break;
+
+      case MATROSKA_ID_TR_CODECPRIVATE:
+        {
+          char *codec_private;
+          if (elem.len >= 0x80000000)
+            return 0;
+          codec_private = malloc (elem.len);
+          if (! codec_private)
+            return 0;
+          lprintf("CodecPrivate\n");
+          if (!ebml_read_binary(ebml, &elem, codec_private)) {
+            free(codec_private);
+            return 0;
+          }
+          track->codec_private = codec_private;
+          track->codec_private_len = elem.len;
+        }
+        break;
+
+      case MATROSKA_ID_TR_LANGUAGE:
+        {
+          char *language = ebml_alloc_read_ascii (ebml, &elem);
+          lprintf("Language\n");
+          if (!language)
+            return 0;
+          track->language = language;
+        }
+        break;
+
       case MATROSKA_ID_TV:
         lprintf("Video\n");
         if (track->video_track)
@@ -1212,8 +1155,8 @@
           return 0;
         if ((elem.len > 0) && !parse_video_track(this, track->video_track))
           return 0;
-      break;
-      
+        break;
+
       case MATROSKA_ID_TA:
         lprintf("Audio\n");
         if (track->audio_track)
@@ -1223,38 +1166,54 @@
           return 0;
         if ((elem.len > 0) && !parse_audio_track(this, track->audio_track))
           return 0;
-      break;
-        
-      case MATROSKA_ID_TR_FLAGDEFAULT: {
-        uint64_t val;
-        
-        lprintf("Default\n");
-        if (!ebml_read_uint(ebml, &elem, &val))
-          return 0;
-        track->default_flag = (int)val;
-      }
-      break;
+        break;
 
-      case MATROSKA_ID_TR_DEFAULTDURATION: {
-        uint64_t val;
+      case MATROSKA_ID_TR_FLAGDEFAULT:
+        {
+          uint64_t val;
 
-        if (!ebml_read_uint(ebml, &elem, &val))
-          return 0;
-        track->default_duration = val;
-        lprintf("Default Duration: %"PRIu64"\n", track->default_duration);
-      }
-      break;
+          lprintf("Default\n");
+          if (!ebml_read_uint(ebml, &elem, &val))
+            return 0;
+          track->default_flag = (int)val;
+        }
+        break;
 
-      case MATROSKA_ID_CONTENTENCODINGS: {
-        lprintf("ContentEncodings\n");
-        if (!ebml_read_master (ebml, &elem))
-          return 0;
-        if ((elem.len > 0) && !parse_content_encodings(this, track))
-          return 0;
-      }
-      break;
+      case MATROSKA_ID_TR_DEFAULTDURATION:
+        {
+          uint64_t val;
+
+          if (!ebml_read_uint(ebml, &elem, &val))
+            return 0;
+          track->default_duration = val;
+          lprintf("Default Duration: %"PRIu64"\n", track->default_duration);
+        }
+        break;
+
+      case MATROSKA_ID_CONTENTENCODINGS:
+        {
+          lprintf("ContentEncodings\n");
+          if (!ebml_read_master (ebml, &elem))
+            return 0;
+          if ((elem.len > 0) && !parse_content_encodings(this, track))
+            return 0;
+        }
+        break;
 
       case MATROSKA_ID_TR_UID:
+        {
+          uint64_t val;
+
+          if (!ebml_read_uint(ebml, &elem, &val)) {
+            lprintf("Track UID (invalid)\n");
+            return 0;
+          }
+
+          track->uid = val;
+          lprintf("Track UID: 0x%" PRIx64 "\n", track->uid);
+        }
+        break;
+
       case MATROSKA_ID_TR_FLAGENABLED:
       case MATROSKA_ID_TR_FLAGLACING:
       case MATROSKA_ID_TR_MINCACHE:
@@ -1275,32 +1234,37 @@
     }
     next_level = ebml_get_next_level(ebml, &elem);
   }
-  
+
   xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
-          "demux_matroska: Track %d, %s %s\n",
-          track->track_num,
-          (track->codec_id ? track->codec_id : ""),
-          (track->language ? track->language : ""));
+      "demux_matroska: Track %d, %s %s\n",
+      track->track_num,
+      (track->codec_id ? track->codec_id : ""),
+      (track->language ? track->language : ""));
   if (track->codec_id) {
     void (*init_codec)(demux_matroska_t *, matroska_track_t *) = NULL;
 
     if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_V_VFW_FOURCC)) {
       xine_bmiheader *bih;
 
-      lprintf("MATROSKA_CODEC_ID_V_VFW_FOURCC\n");
-      bih = (xine_bmiheader*)track->codec_private;
-      _x_bmiheader_le2me(bih);
+      if (track->codec_private_len >= sizeof(xine_bmiheader)) {
+        lprintf("MATROSKA_CODEC_ID_V_VFW_FOURCC\n");
+        bih = (xine_bmiheader*)track->codec_private;
+        _x_bmiheader_le2me(bih);
 
-      track->buf_type = _x_fourcc_to_buf_video(bih->biCompression);
-      init_codec = init_codec_video;
+        track->buf_type = _x_fourcc_to_buf_video(bih->biCompression);
+        init_codec = init_codec_video;
+      }
 
     } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_V_UNCOMPRESSED)) {
     } else if ((!strcmp(track->codec_id, MATROSKA_CODEC_ID_V_MPEG4_SP)) ||
-               (!strcmp(track->codec_id, MATROSKA_CODEC_ID_V_MPEG4_ASP)) ||
-               (!strcmp(track->codec_id, MATROSKA_CODEC_ID_V_MPEG4_AP))) {
+        (!strcmp(track->codec_id, MATROSKA_CODEC_ID_V_MPEG4_ASP)) ||
+        (!strcmp(track->codec_id, MATROSKA_CODEC_ID_V_MPEG4_AP))) {
       xine_bmiheader *bih;
-      
+
       lprintf("MATROSKA_CODEC_ID_V_MPEG4_*\n");
+      if (track->codec_private_len > 0x7fffffff - sizeof(xine_bmiheader))
+        track->codec_private_len = 0x7fffffff - sizeof(xine_bmiheader);
+
       /* create a bitmap info header struct for MPEG 4 */
       bih = calloc(1, sizeof(xine_bmiheader) + track->codec_private_len);
       bih->biSize = sizeof(xine_bmiheader) + track->codec_private_len;
@@ -1308,20 +1272,23 @@
       bih->biWidth = track->video_track->pixel_width;
       bih->biHeight = track->video_track->pixel_height;
       _x_bmiheader_le2me(bih);
-      
+
       /* add bih extra data */
       memcpy(bih + 1, track->codec_private, track->codec_private_len);
       free(track->codec_private);
       track->codec_private = (uint8_t *)bih;
       track->codec_private_len = bih->biSize;
       track->buf_type = BUF_VIDEO_MPEG4;
-      
+
       /* init as a vfw decoder */
       init_codec = init_codec_video;
     } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_V_MPEG4_AVC)) {
       xine_bmiheader *bih;
-      
+
       lprintf("MATROSKA_CODEC_ID_V_MPEG4_AVC\n");
+      if (track->codec_private_len > 0x7fffffff - sizeof(xine_bmiheader))
+        track->codec_private_len = 0x7fffffff - sizeof(xine_bmiheader);
+
       /* create a bitmap info header struct for h264 */
       bih = calloc(1, sizeof(xine_bmiheader) + track->codec_private_len);
       bih->biSize = sizeof(xine_bmiheader) + track->codec_private_len;
@@ -1329,14 +1296,14 @@
       bih->biWidth = track->video_track->pixel_width;
       bih->biHeight = track->video_track->pixel_height;
       _x_bmiheader_le2me(bih);
-      
+
       /* add bih extra data */
       memcpy(bih + 1, track->codec_private, track->codec_private_len);
       free(track->codec_private);
       track->codec_private = (uint8_t *)bih;
       track->codec_private_len = bih->biSize;
       track->buf_type = BUF_VIDEO_H264;
-      
+
       /* init as a vfw decoder */
       init_codec = init_codec_video;
     } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_V_MSMPEG4V3)) {
@@ -1357,7 +1324,7 @@
       track->handle_content = handle_realvideo;
       init_codec = init_codec_real;
     } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_V_REAL_RV40)) {
-    
+
       lprintf("MATROSKA_CODEC_ID_V_REAL_RV40\n");
       track->buf_type = BUF_VIDEO_RV40;
       track->handle_content = handle_realvideo;
@@ -1369,8 +1336,8 @@
       track->buf_type = BUF_VIDEO_THEORA_RAW;
       init_codec = init_codec_xiph;
     } else if ((!strcmp(track->codec_id, MATROSKA_CODEC_ID_A_MPEG1_L1)) ||
-               (!strcmp(track->codec_id, MATROSKA_CODEC_ID_A_MPEG1_L2)) ||
-               (!strcmp(track->codec_id, MATROSKA_CODEC_ID_A_MPEG1_L3))) {
+        (!strcmp(track->codec_id, MATROSKA_CODEC_ID_A_MPEG1_L2)) ||
+        (!strcmp(track->codec_id, MATROSKA_CODEC_ID_A_MPEG1_L3))) {
       lprintf("MATROSKA_CODEC_ID_A_MPEG1\n");
       track->buf_type = BUF_AUDIO_MPEG;
       init_codec = init_codec_audio;
@@ -1382,7 +1349,7 @@
       lprintf("MATROSKA_CODEC_ID_A_AC3\n");
       track->buf_type = BUF_AUDIO_A52;
       init_codec = init_codec_audio;
-      
+
     } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_A_DTS)) {
       lprintf("MATROSKA_CODEC_ID_A_DTS\n");
       track->buf_type = BUF_AUDIO_DTS;
@@ -1398,13 +1365,15 @@
       xine_waveformatex *wfh;
       lprintf("MATROSKA_CODEC_ID_A_ACM\n");
 
-      wfh = (xine_waveformatex*)track->codec_private;
-      _x_waveformatex_le2me(wfh);
+      if (track->codec_private_len >= sizeof(xine_waveformatex)) {
+        wfh = (xine_waveformatex*)track->codec_private;
+        _x_waveformatex_le2me(wfh);
 
-      track->buf_type = _x_formattag_to_buf_audio(wfh->wFormatTag);
-      init_codec = init_codec_audio;
+        track->buf_type = _x_formattag_to_buf_audio(wfh->wFormatTag);
+        init_codec = init_codec_audio;
+      }
     } else if (!strncmp(track->codec_id, MATROSKA_CODEC_ID_A_AAC,
-                        sizeof(MATROSKA_CODEC_ID_A_AAC) - 1)) {
+          sizeof(MATROSKA_CODEC_ID_A_AAC) - 1)) {
       lprintf("MATROSKA_CODEC_ID_A_AAC\n");
       track->buf_type = BUF_AUDIO_AAC;
       init_codec = init_codec_aac;
@@ -1424,17 +1393,17 @@
       track->buf_type = BUF_AUDIO_ATRK;
       init_codec = init_codec_real;
     } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_S_TEXT_UTF8) ||
-               !strcmp(track->codec_id, MATROSKA_CODEC_ID_S_UTF8)) {
+        !strcmp(track->codec_id, MATROSKA_CODEC_ID_S_UTF8)) {
       lprintf("MATROSKA_CODEC_ID_S_TEXT_UTF8\n");
       track->buf_type = BUF_SPU_OGM;
       track->handle_content = handle_sub_utf8;
     } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_S_TEXT_SSA) ||
-               !strcmp(track->codec_id, MATROSKA_CODEC_ID_S_SSA)) {
+        !strcmp(track->codec_id, MATROSKA_CODEC_ID_S_SSA)) {
       lprintf("MATROSKA_CODEC_ID_S_TEXT_SSA\n");
       track->buf_type = BUF_SPU_OGM;
       track->handle_content = handle_sub_ssa;
     } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_S_TEXT_ASS) ||
-               !strcmp(track->codec_id, MATROSKA_CODEC_ID_S_ASS)) {
+        !strcmp(track->codec_id, MATROSKA_CODEC_ID_S_ASS)) {
       lprintf("MATROSKA_CODEC_ID_S_TEXT_ASS\n");
       track->buf_type = BUF_SPU_OGM;
       track->handle_content = handle_sub_ssa;
@@ -1447,7 +1416,7 @@
       track->buf_type = BUF_SPU_DVD;
       track->handle_content = handle_vobsub;
       init_codec = init_codec_vobsub;
-      
+
       /* Enable autodetection of the zlib compression, unless it was
        * explicitely set. Most vobsubs are compressed with zlib but
        * are not declared as such.
@@ -1483,12 +1452,17 @@
           break;
       }
 
-      if (init_codec)
+      if (init_codec) {
+        if (! track->fifo) {
+          xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+              "demux_matroska: Error: fifo not set up for track of type type %" PRIu32 "\n", track->track_type);
+          return 0;
+        }
         init_codec(this, track);
-      
+      }
     }
   }
-  
+
   return 1;
 }
 
@@ -1496,10 +1470,10 @@
 static int parse_tracks(demux_matroska_t *this) {
   ebml_parser_t *ebml = this->ebml;
   int next_level = 2;
-  
+
   while (next_level == 2) {
     ebml_elem_t elem;
-    
+
     if (!ebml_read_elem_head(ebml, &elem))
       return 0;
 
@@ -1507,6 +1481,12 @@
       case MATROSKA_ID_TR_ENTRY: {
         matroska_track_t *track;
 
+        /* bail out early if no more tracks can be handled! */
+        if (this->num_tracks >= MAX_STREAMS) {
+          lprintf("Too many tracks!\n");
+          return 0;
+        }
+
         /* alloc and initialize a track with 0 */
         track = calloc(1, sizeof(matroska_track_t));
         track->compress_algo = MATROSKA_COMPRESS_NONE;
@@ -1520,29 +1500,7 @@
         this->num_tracks++;
       }
       break;
-      
-      default:
-        lprintf("Unhandled ID: 0x%x\n", elem.id);
-        if (!ebml_skip(ebml, &elem))
-          return 0;
-    }
-    next_level = ebml_get_next_level(ebml, &elem);
-  }
-  return 1;
-}
-
-
-static int parse_chapters(demux_matroska_t *this) {
-  ebml_parser_t *ebml = this->ebml;
-  int next_level = 2;
-  
-  while (next_level == 2) {
-    ebml_elem_t elem;
-    
-    if (!ebml_read_elem_head(ebml, &elem))
-      return 0;
 
-    switch (elem.id) {
       default:
         lprintf("Unhandled ID: 0x%x\n", elem.id);
         if (!ebml_skip(ebml, &elem))
@@ -1553,15 +1511,14 @@
   return 1;
 }
 
-
 static int parse_cue_trackposition(demux_matroska_t *this, int *track_num,
                                    int64_t *pos) {
   ebml_parser_t *ebml = this->ebml;
   int next_level = 4;
-  
+
   while (next_level == 4) {
     ebml_elem_t elem;
-    
+
     if (!ebml_read_elem_head(ebml, &elem))
       return 0;
 
@@ -1598,10 +1555,10 @@
   int next_level = 3;
   int64_t timecode = -1, pos = -1;
   int track_num = -1;
-  
+
   while (next_level == 3) {
     ebml_elem_t elem;
-    
+
     if (!ebml_read_elem_head(ebml, &elem))
       return 0;
 
@@ -1666,10 +1623,10 @@
 static int parse_cues(demux_matroska_t *this) {
   ebml_parser_t *ebml = this->ebml;
   int next_level = 2;
-  
+
   while (next_level == 2) {
     ebml_elem_t elem;
-    
+
     if (!ebml_read_elem_head(ebml, &elem))
       return 0;
 
@@ -1695,10 +1652,10 @@
 static int parse_attachments(demux_matroska_t *this) {
   ebml_parser_t *ebml = this->ebml;
   int next_level = 2;
-  
+
   while (next_level == 2) {
     ebml_elem_t elem;
-    
+
     if (!ebml_read_elem_head(ebml, &elem))
       return 0;
 
@@ -1717,10 +1674,10 @@
 static int parse_tags(demux_matroska_t *this) {
   ebml_parser_t *ebml = this->ebml;
   int next_level = 2;
-  
+
   while (next_level == 2) {
     ebml_elem_t elem;
-    
+
     if (!ebml_read_elem_head(ebml, &elem))
       return 0;
 
@@ -1759,7 +1716,7 @@
   }
   if (size > 8) {
     off_t pos = this->input->get_current_pos(this->input);
-    xprintf(this->stream->xine, XINE_VERBOSITY_LOG, 
+    xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
             "demux_matroska: Invalid Track Number at position %" PRIdMAX "\n",
             (intmax_t)pos);
     return 0;
@@ -1788,7 +1745,7 @@
     *num = -1;
   else
     *num = unum - ((1 << ((7 * size) - 1)) - 1);
-  
+
   return size;
 }
 
@@ -1811,6 +1768,11 @@
   alloc_block_data(this, len);
 
   /* block datas */
+  if (! this->block_data) {
+    xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+            "demux_matroska: memory allocation error\n");
+    return 0;
+  }
   if (this->input->read(this->input, this->block_data, len) != len) {
     off_t pos = this->input->get_current_pos(this->input);
     xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
@@ -1838,7 +1800,7 @@
   uint8_t          *data;
   uint8_t           flags;
   int               gap, lacing, num_len;
-  int               timecode_diff;
+  int16_t           timecode_diff;
   int64_t           pts, xduration;
   int               decoder_flags = 0;
 
@@ -1848,12 +1810,12 @@
   data += num_len;
 
   /* timecode_diff is signed */
-  timecode_diff = parse_int16(data);
+  timecode_diff = (int16_t)parse_int16(data);
   data += 2;
 
   flags = *data;
   data += 1;
-  
+
   lprintf("track_num: %" PRIu64 ", timecode_diff: %d, flags: 0x%x\n", track_num, timecode_diff, flags);
 
   gap = flags & 1;
@@ -1960,7 +1922,7 @@
         int frame_size;
 
         lprintf("fixed size lacing\n");
-        
+
         frame_size = block_size_left / (lace_num + 1);
         for (i = 0; i < lace_num; i++) {
           frame[i] = frame_size;
@@ -2049,6 +2011,31 @@
   return 1;
 }
 
+static int parse_simpleblock(demux_matroska_t *this, size_t block_len, uint64_t cluster_timecode, uint64_t block_duration)
+{
+  int has_block           = 0;
+  off_t block_pos         = 0;
+  off_t file_len          = 0;
+  int normpos             = 0;
+  int is_key              = 1;
+
+  lprintf("simpleblock\n");
+  block_pos = this->input->get_current_pos(this->input);
+  file_len = this->input->get_length(this->input);
+  if( file_len )
+    normpos = (int) ( (double) block_pos * 65535 / file_len );
+
+  if (!read_block_data(this, block_len))
+    return 0;
+
+  has_block = 1;
+    /* we have the duration, we can parse the block now */
+  if (!parse_block(this, block_len, cluster_timecode, block_duration,
+                   normpos, is_key))
+    return 0;
+  return 1;
+}
+
 static int parse_block_group(demux_matroska_t *this,
                              uint64_t cluster_timecode,
                              uint64_t cluster_duration) {
@@ -2111,9 +2098,52 @@
   return 1;
 }
 
+static int demux_matroska_seek (demux_plugin_t*, off_t, int, int);
+
+static void handle_events(demux_matroska_t *this) {
+  xine_event_t* event;
+
+  while ((event = xine_event_get(this->event_queue))) {
+    if (this->num_editions > 0) {
+      matroska_edition_t* ed = this->editions[0];
+      int chapter_idx = matroska_get_chapter(this, this->last_timecode, &ed);
+      uint64_t next_time;
+
+      if (chapter_idx < 0) {
+        xine_event_free(event);
+        continue;
+      }
+
+      switch(event->type) {
+        case XINE_EVENT_INPUT_NEXT:
+          if (chapter_idx < ed->num_chapters-1) {
+            next_time = ed->chapters[chapter_idx+1]->time_start / 90;
+            demux_matroska_seek((demux_plugin_t*)this, 0, next_time, 1);
+          }
+          break;
+
+          /* TODO: should this try to implement common "start of chapter"
+           *  functionality? */
+        case XINE_EVENT_INPUT_PREVIOUS:
+          if (chapter_idx > 0) {
+            next_time = ed->chapters[chapter_idx-1]->time_start / 90;
+            demux_matroska_seek((demux_plugin_t*)this, 0, next_time, 1);
+          }
+          break;
+
+        default:
+          break;
+      }
+    }
+
+    xine_event_free(event);
+  }
+}
+
 static int parse_cluster(demux_matroska_t *this) {
   ebml_parser_t *ebml = this->ebml;
-  int next_level = 2;
+  int this_level = ebml->level;
+  int next_level = this_level;
   uint64_t timecode = 0;
   uint64_t duration = 0;
 
@@ -2130,7 +2160,9 @@
     this->first_cluster_found = 1;
   }
 
-  while (next_level == 2) {
+  handle_events(this);
+
+  while (next_level == this_level) {
     ebml_elem_t elem;
 
     if (!ebml_read_elem_head(ebml, &elem))
@@ -2154,6 +2186,11 @@
         if ((elem.len > 0) && !parse_block_group(this, timecode, duration))
           return 0;
         break;
+      case MATROSKA_ID_CL_SIMPLEBLOCK:
+        lprintf("simpleblock\n");
+        if (!parse_simpleblock(this, elem.len, timecode, duration))
+          return 0;
+        break;
       case MATROSKA_ID_CL_BLOCK:
         lprintf("block\n");
         if (!ebml_skip(ebml, &elem))
@@ -2166,6 +2203,49 @@
     }
     next_level = ebml_get_next_level(ebml, &elem);
   }
+
+  /* at this point, we MUST have a timecode (according to format spec).
+   * Use that to find the chapter we are in, and adjust the title.
+   *
+   * TODO: this only looks at the chapters in the first edition.
+   */
+
+  this->last_timecode = timecode;
+
+  if (this->num_editions <= 0)
+    return 1;
+  matroska_edition_t *ed = this->editions[0];
+
+  if (ed->num_chapters <= 0)
+    return 1;
+
+  /* fix up a makeshift title if none has been set yet (e.g. filename) */
+  if (NULL == this->title && NULL != _x_meta_info_get(this->stream, XINE_META_INFO_TITLE))
+    this->title = strdup(_x_meta_info_get(this->stream, XINE_META_INFO_TITLE));
+
+  if (NULL == this->title)
+    this->title = strdup("(No title)");
+
+  if (NULL == this->title) {
+    lprintf("Failed to determine a valid stream title!\n");
+    return 1;
+  }
+
+  int chapter_idx = matroska_get_chapter(this, timecode, &ed);
+  if (chapter_idx < 0) {
+    _x_meta_info_set_utf8(this->stream, XINE_META_INFO_TITLE, this->title);
+    return 1;
+  }
+
+  xine_ui_data_t uidata = {
+    .str = {0, },
+    .str_len = 0,
+  };
+
+  uidata.str_len = snprintf(uidata.str, sizeof(uidata.str), "%s / (%d) %s",
+      this->title, chapter_idx+1, ed->chapters[chapter_idx]->title);
+  _x_meta_info_set_utf8(this->stream, XINE_META_INFO_TITLE, uidata.str);
+
   return 1;
 }
 
@@ -2178,10 +2258,10 @@
   int has_position = 0;
   uint64_t id = 0;
   uint64_t pos;
-  
+
   while (next_level == 3) {
     ebml_elem_t elem;
-    
+
     if (!ebml_read_elem_head(ebml, &elem))
       return 0;
 
@@ -2205,26 +2285,26 @@
     }
     next_level = ebml_get_next_level(ebml, &elem);
   }
-  
+
   /* do not parse clusters */
   if (id == MATROSKA_ID_CLUSTER) {
     lprintf("skip cluster\n");
     return 1;
   }
-  
-  /* parse the referenced element */  
+
+  /* parse the referenced element */
   if (has_id && has_position) {
     off_t current_pos, seek_pos;
-    
+
     seek_pos = this->segment.start + pos;
-    
+
     if ((seek_pos > 0) && (seek_pos < this->input->get_length(this->input))) {
       ebml_parser_t ebml_bak;
 
       /* backup current state */
       current_pos = this->input->get_current_pos(this->input);
       memcpy(&ebml_bak, this->ebml, sizeof(ebml_parser_t));   /* FIXME */
-    
+
       /* seek and parse the top_level element */
       this->ebml->level = 1;
       if (this->input->seek(this->input, seek_pos, SEEK_SET) < 0) {
@@ -2263,7 +2343,7 @@
 
   while (next_level == 2) {
     ebml_elem_t elem;
-    
+
     if (!ebml_read_elem_head(ebml, &elem))
       return 0;
 
@@ -2300,18 +2380,19 @@
   ebml_elem_t elem;
   int ret_value = 1;
   off_t current_pos;
-  
+
+
   current_pos = this->input->get_current_pos(this->input);
   lprintf("current_pos: %" PRIdMAX "\n", (intmax_t)current_pos);
-  
+
   if (!ebml_read_elem_head(ebml, &elem))
     return 0;
-    
+
   if (!find_top_level_entry(this, current_pos)) {
 
     if (!add_top_level_entry(this, current_pos))
       return 0;
-    
+
     switch (elem.id) {
       case MATROSKA_ID_SEEKHEAD:
         lprintf("SeekHead\n");
@@ -2338,7 +2419,7 @@
         lprintf("Chapters\n");
         if (!ebml_read_master (ebml, &elem))
           return 0;
-        if ((elem.len > 0) && !parse_chapters(this))
+        if ((elem.len > 0) && !matroska_parse_chapters(this))
           return 0;
         break;
       case MATROSKA_ID_CLUSTER:
@@ -2378,7 +2459,7 @@
     if (!ebml_skip(ebml, &elem))
       return 0;
   }
-  
+
   if (next_level)
     *next_level = ebml_get_next_level(ebml, &elem);
 
@@ -2465,12 +2546,12 @@
   if (this->segment.id == MATROSKA_ID_SEGMENT) {
     int res;
     int next_level;
-    
+
     lprintf("Segment detected\n");
 
     if (!ebml_read_master (ebml, &this->segment))
       return 0;
-    
+
     res = 1;
     next_level = 1;
     /* stop the loop on the first cluster */
@@ -2522,14 +2603,14 @@
   _x_stream_info_set(this->stream, XINE_STREAM_INFO_HAS_VIDEO, (this->num_video_tracks != 0));
   _x_stream_info_set(this->stream, XINE_STREAM_INFO_HAS_AUDIO, (this->num_audio_tracks != 0));
 
-    
+
   /*
    * send preview buffers
    */
 
   /* enter in the segment */
   ebml_read_master (this->ebml, &this->segment);
-  
+
   /* seek back to the beginning of the segment */
   next_level = 1;
   if (this->input->seek(this->input, this->segment.start, SEEK_SET) < 0) {
@@ -2539,7 +2620,7 @@
     this->status = DEMUX_FINISHED;
     return;
   }
-  
+
   this->preview_sent = 0;
   this->preview_mode = 1;
 
@@ -2625,7 +2706,7 @@
   matroska_index_t *index;
   matroska_track_t *track;
   int i, entry;
-  
+
   start_pos = (off_t) ( (double) start_pos / 65535 *
               this->input->get_length (this->input) );
 
@@ -2681,10 +2762,10 @@
             index->track_num, start_pos ? "pos" : "time",
             start_pos ? (intmax_t)start_pos : (intmax_t)start_time,
             index->track_num, index->timecode[entry], (intmax_t)index->pos[entry]);
-    
+
     if (this->input->seek(this->input, index->pos[entry], SEEK_SET) < 0)
       this->status = DEMUX_FINISHED;
-    
+
     /* we always seek to the ebml level 1 */
     this->ebml->level = 1;
 
@@ -2698,10 +2779,12 @@
 
 
 static void demux_matroska_dispose (demux_plugin_t *this_gen) {
-  
+
   demux_matroska_t *this = (demux_matroska_t *) this_gen;
   int i;
 
+  free(this->block_data);
+
   /* free tracks */
   for (i = 0; i < this->num_tracks; i++) {
     matroska_track_t *track;
@@ -2719,7 +2802,7 @@
       free (track->audio_track);
     if (track->sub_track)
       free (track->sub_track);
-    
+
     free (track);
   }
   /* Free the cues. */
@@ -2731,12 +2814,17 @@
   }
   if (this->indexes)
     free(this->indexes);
-    
-  /* Free the top_level elem list */    
+
+  /* Free the top_level elem list */
   if (this->top_level_list)
     free(this->top_level_list);
 
+  free(this->title);
+
+  matroska_free_editions(this);
+
   dispose_ebml_parser(this->ebml);
+  xine_event_dispose_queue(this->event_queue);
   free (this);
 }
 
@@ -2750,7 +2838,13 @@
 
 
 static uint32_t demux_matroska_get_capabilities (demux_plugin_t *this_gen) {
-  return DEMUX_CAP_SPULANG | DEMUX_CAP_AUDIOLANG;
+  demux_matroska_t* this = (demux_matroska_t*)this_gen;
+  uint32_t caps = DEMUX_CAP_SPULANG | DEMUX_CAP_AUDIOLANG;
+
+  if(this->num_editions > 0 && this->editions[0]->num_chapters > 0)
+    caps |= DEMUX_CAP_CHAPTERS;
+
+  return caps;
 }
 
 
@@ -2767,7 +2861,7 @@
       if ((channel >= 0) && (channel < this->num_sub_tracks)) {
         for (track_num = 0; track_num < this->num_tracks; track_num++) {
           matroska_track_t *track = this->tracks[track_num];
-          
+
           if ((track->buf_type & 0xFF00001F) == (BUF_SPU_BASE + channel)) {
             if (track->language) {
               strncpy (str, track->language, XINE_LANG_MAX);
@@ -2783,13 +2877,13 @@
         }
       }
       return DEMUX_OPTIONAL_UNSUPPORTED;
-      
+
     case DEMUX_OPTIONAL_DATA_AUDIOLANG:
       lprintf ("DEMUX_OPTIONAL_DATA_AUDIOLANG channel = %d\n",channel);
       if ((channel >= 0) && (channel < this->num_audio_tracks)) {
         for (track_num = 0; track_num < this->num_tracks; track_num++) {
           matroska_track_t *track = this->tracks[track_num];
-          
+
           if ((track->buf_type & 0xFF00001F) == (BUF_AUDIO_BASE + channel)) {
             if (track->language) {
               strncpy (str, track->language, XINE_LANG_MAX);
@@ -2881,11 +2975,18 @@
   if (strcmp(ebml->doctype, "matroska"))
     goto error;
 
+  this->event_queue = xine_event_new_queue(this->stream);
+
   return &this->demux_plugin;
 
 error:
   dispose_ebml_parser(ebml);
-  free(this);
+
+  if (NULL != this) {
+    xine_event_dispose_queue(this->event_queue);
+    free(this);
+  }
+
   return NULL;
 }
 
diff -Nru xine-lib-1.1.16.4-orig/src/demuxers/demux_matroska-chapters.c xine-lib-1.1.16.4-lmce0/src/demuxers/demux_matroska-chapters.c
--- xine-lib-1.1.16.4-orig/src/demuxers/demux_matroska-chapters.c	1970-01-01 00:00:00.000000000 +0000
+++ xine-lib-1.1.16.4-lmce0/src/demuxers/demux_matroska-chapters.c	2010-07-21 12:33:23.000000000 +0000
@@ -0,0 +1,433 @@
+/*
+ * Copyright (C) 2009 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * demultiplexer for matroska streams: chapter handling
+ *
+ * TODO:
+ *  - nested chapters
+ *
+ * Authors:
+ *  Nicos Gollan <gtdev@spearhead.de>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#define LOG_MODULE "demux_matroska_chapters"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+
+#include "xine_internal.h"
+#include "xineutils.h"
+#include "demux.h"
+
+#include "ebml.h"
+#include "matroska.h"
+#include "demux_matroska.h"
+
+/* TODO: this only handles one single (title, language, country) tuple.
+ *  See the header for information. */
+static int parse_chapter_display(demux_matroska_t *this, matroska_chapter_t *chap, int level) {
+  ebml_parser_t *ebml = this->ebml;
+  int next_level = level+1;
+  char* tmp_name = NULL;
+  char* tmp_lang = NULL;
+  char* tmp_country = NULL;
+
+  while (next_level == level+1) {
+    ebml_elem_t elem;
+
+    if (!ebml_read_elem_head(ebml, &elem))
+      return 0;
+
+    switch (elem.id) {
+
+      case MATROSKA_ID_CH_STRING:
+        tmp_name = ebml_alloc_read_ascii(ebml, &elem);
+        break;
+
+      case MATROSKA_ID_CH_LANGUAGE:
+        tmp_lang = ebml_alloc_read_ascii(ebml, &elem);
+        break;
+
+      case MATROSKA_ID_CH_COUNTRY:
+        tmp_country = ebml_alloc_read_ascii(ebml, &elem);
+        break;
+
+      default:
+        lprintf("Unhandled ID (inside ChapterDisplay): 0x%x\n", elem.id);
+        if (!ebml_skip(ebml, &elem))
+          return 0;
+    }
+
+    next_level = ebml_get_next_level(ebml, &elem);
+  }
+
+  if (NULL != chap->title) {
+    chap->title = tmp_name;
+
+    free(chap->language);
+    chap->language = tmp_lang;
+
+    free(chap->country);
+    chap->country = tmp_country;
+  } else if (tmp_lang != NULL && !strcmp("eng", tmp_lang) && (chap->language == NULL || strcmp("eng", chap->language))) {
+    free(chap->title);
+    chap->title = tmp_name;
+
+    free(chap->language);
+    chap->language = tmp_lang;
+
+    free(chap->country);
+    chap->country = tmp_country;
+  } else {
+    free(tmp_name);
+    free(tmp_lang);
+    free(tmp_country);
+  }
+
+  return 1;
+}
+
+static int parse_chapter_atom(demux_matroska_t *this, matroska_chapter_t *chap, int level) {
+  ebml_parser_t *ebml = this->ebml;
+  int next_level = level+1;
+  uint64_t num;
+
+  chap->time_start = 0;
+  chap->time_end = 0;
+  chap->hidden = 0;
+  chap->enabled = 1;
+
+  while (next_level == level+1) {
+    ebml_elem_t elem;
+
+    if (!ebml_read_elem_head(ebml, &elem)) {
+      lprintf("invalid head\n");
+      return 0;
+    }
+
+    switch (elem.id) {
+      case MATROSKA_ID_CH_UID:
+        if (!ebml_read_uint(ebml, &elem, &chap->uid)) {
+          lprintf("invalid UID\n");
+          return 0;
+        }
+        break;
+
+      case MATROSKA_ID_CH_TIMESTART:
+        if (!ebml_read_uint(ebml, &elem, &chap->time_start)) {
+          lprintf("invalid start time\n");
+          return 0;
+        }
+        /* convert to xine timing: Matroska timestamps are in nanoseconds,
+         * xine's PTS are in 1/90,000s */
+        chap->time_start /= 100000;
+        chap->time_start *= 9;
+        break;
+
+      case MATROSKA_ID_CH_TIMEEND:
+        if (!ebml_read_uint(ebml, &elem, &chap->time_end)) {
+          lprintf("invalid end time\n");
+          return 0;
+        }
+        /* convert to xine timing */
+        chap->time_end /= 100000;
+        chap->time_end *= 9;
+        break;
+
+      case MATROSKA_ID_CH_DISPLAY:
+        if (!ebml_read_master(ebml, &elem))
+          return 0;
+
+        lprintf("ChapterDisplay\n");
+        if(!parse_chapter_display(this, chap, level+1)) {
+          lprintf("invalid display information\n");
+          return 0;
+        }
+        break;
+
+      case MATROSKA_ID_CH_HIDDEN:
+        if (!ebml_read_uint(ebml, &elem, &num))
+          return 0;
+        chap->hidden = (int)num;
+        break;
+
+      case MATROSKA_ID_CH_ENABLED:
+        if (!ebml_read_uint(ebml, &elem, &num))
+          return 0;
+        chap->enabled = (int)num;
+        break;
+
+      case MATROSKA_ID_CH_ATOM: /* TODO */
+        xprintf(this->stream->xine, XINE_VERBOSITY_NONE,
+            LOG_MODULE ": Warning: Nested chapters are not supported, playback may suffer!\n");
+        if (!ebml_skip(ebml, &elem))
+          return 0;
+        break;
+
+      case MATROSKA_ID_CH_TRACK: /* TODO */
+        xprintf(this->stream->xine, XINE_VERBOSITY_NONE,
+            LOG_MODULE ": Warning: Specific track information in chapters is not supported, playback may suffer!\n");
+        if (!ebml_skip(ebml, &elem))
+          return 0;
+        break;
+
+      default:
+        lprintf("Unhandled ID (inside ChapterAtom): 0x%x\n", elem.id);
+        if (!ebml_skip(ebml, &elem))
+          return 0;
+    }
+
+    next_level = ebml_get_next_level(ebml, &elem);
+  }
+
+  /* fallback information */
+  /* FIXME: check allocations! */
+  if (NULL == chap->title) {
+    chap->title = malloc(9);
+    if (chap->title != NULL)
+      strncpy(chap->title, "No title", 9);
+  }
+
+  if (NULL == chap->language) {
+    chap->language = malloc(4);
+    if (chap->language != NULL)
+      strncpy(chap->language, "unk", 4);
+  }
+
+  if (NULL == chap->country) {
+    chap->country = malloc(3);
+    if (chap->country != NULL)
+      strncpy(chap->country, "XX", 3);
+  }
+
+  lprintf( "Chapter 0x%" PRIx64 ": %" PRIu64 "-%" PRIu64 "(pts), %s (%s). %shidden, %senabled.\n",
+      chap->uid, chap->time_start, chap->time_end,
+      chap->title, chap->language,
+      (chap->hidden ? "" : "not "),
+      (chap->enabled ? "" : "not "));
+
+  return 1;
+}
+
+static void free_chapter(demux_matroska_t *this, matroska_chapter_t *chap) {
+  free(chap->title);
+  free(chap->language);
+  free(chap->country);
+
+  free(chap);
+}
+
+static int parse_edition_entry(demux_matroska_t *this, matroska_edition_t *ed) {
+  ebml_parser_t *ebml = this->ebml;
+  int next_level = 3;
+  uint64_t num;
+  int i;
+
+  ed->hidden = 0;
+  ed->is_default = 0;
+  ed->ordered = 0;
+
+  while (next_level == 3) {
+    ebml_elem_t elem;
+
+    if (!ebml_read_elem_head(ebml, &elem))
+      return 0;
+
+    switch (elem.id) {
+      case MATROSKA_ID_CH_ED_UID:
+        if (!ebml_read_uint(ebml, &elem, &ed->uid))
+          return 0;
+        break;
+
+      case MATROSKA_ID_CH_ED_HIDDEN:
+        if (!ebml_read_uint(ebml, &elem, &num))
+          return 0;
+        ed->hidden = (int)num;
+        break;
+
+      case MATROSKA_ID_CH_ED_DEFAULT:
+        if (!ebml_read_uint(ebml, &elem, &num))
+          return 0;
+        ed->is_default = (int)num;
+        break;
+
+      case MATROSKA_ID_CH_ED_ORDERED:
+        if (!ebml_read_uint(ebml, &elem, &num))
+          return 0;
+        ed->ordered = (int)num;
+        break;
+
+      case MATROSKA_ID_CH_ATOM:
+        {
+          matroska_chapter_t *chapter = calloc(1, sizeof(matroska_chapter_t));
+          if (NULL == chapter)
+            return 0;
+
+          lprintf("ChapterAtom\n");
+          if (!ebml_read_master(ebml, &elem))
+            return 0;
+
+          if (!parse_chapter_atom(this, chapter, next_level))
+            return 0;
+
+          /* resize chapters array if necessary */
+          if (ed->num_chapters >= ed->cap_chapters) {
+            matroska_chapter_t** old_chapters = ed->chapters;
+            ed->cap_chapters += 10;
+            ed->chapters = realloc(ed->chapters, ed->cap_chapters * sizeof(matroska_chapter_t*));
+
+            if (NULL == ed->chapters) {
+              ed->chapters = old_chapters;
+              ed->cap_chapters -= 10;
+              return 0;
+            }
+          }
+
+          ed->chapters[ed->num_chapters] = chapter;
+          ++ed->num_chapters;
+
+          break;
+        }
+
+      default:
+        lprintf("Unhandled ID (inside EditionEntry): 0x%x\n", elem.id);
+        if (!ebml_skip(ebml, &elem))
+          return 0;
+    }
+
+    next_level = ebml_get_next_level(ebml, &elem);
+  }
+
+  xprintf( this->stream->xine, XINE_VERBOSITY_LOG,
+      LOG_MODULE ": Edition 0x%" PRIx64 ": %shidden, %sdefault, %sordered. %d chapters:\n",
+      ed->uid,
+      (ed->hidden ? "" : "not "),
+      (ed->is_default ? "" : "not "),
+      (ed->ordered ? "" : "not "),
+      ed->num_chapters );
+
+  for (i=0; i<ed->num_chapters; ++i) {
+    matroska_chapter_t* chap = ed->chapters[i];
+    xprintf( this->stream->xine, XINE_VERBOSITY_LOG,
+        LOG_MODULE ":  Chapter %d: %" PRIu64 "-%" PRIu64 "(pts), %s (%s). %shidden, %senabled.\n",
+        i+1, chap->time_start, chap->time_end,
+        chap->title, chap->language,
+        (chap->hidden ? "" : "not "),
+        (chap->enabled ? "" : "not "));
+  }
+
+  return 1;
+}
+
+static void free_edition(demux_matroska_t *this, matroska_edition_t *ed) {
+  int i;
+
+  for(i=0; i<ed->num_chapters; ++i) {
+    free_chapter(this, ed->chapters[i]);
+  }
+  free(ed->chapters);
+  free(ed);
+}
+
+int matroska_parse_chapters(demux_matroska_t *this) {
+  ebml_parser_t *ebml = this->ebml;
+  int next_level = 2;
+
+  while (next_level == 2) {
+    ebml_elem_t elem;
+
+    if (!ebml_read_elem_head(ebml, &elem))
+      return 0;
+
+    switch (elem.id) {
+      case MATROSKA_ID_CH_EDITIONENTRY:
+        {
+          matroska_edition_t *edition = calloc(1, sizeof(matroska_edition_t));
+          if (NULL == edition)
+            return 0;
+
+          lprintf("EditionEntry\n");
+          if (!ebml_read_master(ebml, &elem))
+            return 0;
+
+          if (!parse_edition_entry(this, edition))
+            return 0;
+
+          /* resize editions array if necessary */
+          if (this->num_editions >= this->cap_editions) {
+            matroska_edition_t** old_editions = this->editions;
+            this->cap_editions += 10;
+            this->editions = realloc(this->editions, this->cap_editions * sizeof(matroska_edition_t*));
+
+            if (NULL == this->editions) {
+              this->editions = old_editions;
+              this->cap_editions -= 10;
+              return 0;
+            }
+          }
+
+          this->editions[this->num_editions] = edition;
+          ++this->num_editions;
+
+          break;
+        }
+
+      default:
+        lprintf("Unhandled ID: 0x%x\n", elem.id);
+        if (!ebml_skip(ebml, &elem))
+          return 0;
+    }
+
+    next_level = ebml_get_next_level(ebml, &elem);
+  }
+
+  return 1;
+}
+
+void matroska_free_editions(demux_matroska_t *this) {
+  int i;
+
+  for(i=0; i<this->num_editions; ++i) {
+    free_edition(this, this->editions[i]);
+  }
+  free(this->editions);
+  this->num_editions = 0;
+  this->cap_editions = 0;
+}
+
+int matroska_get_chapter(demux_matroska_t *this, uint64_t tc, matroska_edition_t** ed) {
+  uint64_t block_pts = (tc * this->timecode_scale) / 100000 * 9;
+  int chapter_idx = 0;
+
+  if (this->num_editions < 1)
+    return -1;
+
+  while (chapter_idx < (*ed)->num_chapters && block_pts > (*ed)->chapters[chapter_idx]->time_start)
+    ++chapter_idx;
+
+  if (chapter_idx > 0)
+    --chapter_idx;
+
+  return chapter_idx;
+}
diff -Nru xine-lib-1.1.16.4-orig/src/demuxers/demux_matroska.h xine-lib-1.1.16.4-lmce0/src/demuxers/demux_matroska.h
--- xine-lib-1.1.16.4-orig/src/demuxers/demux_matroska.h	1970-01-01 00:00:00.000000000 +0000
+++ xine-lib-1.1.16.4-lmce0/src/demuxers/demux_matroska.h	2010-07-21 12:33:23.000000000 +0000
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2000-2008 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * demultiplexer for matroska streams: shared header
+ */
+
+#ifndef _DEMUX_MATROSKA_H_
+#define _DEMUX_MATROSKA_H_
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <ctype.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <zlib.h>
+
+#include "xine_internal.h"
+#include "demux.h"
+#include "buffer.h"
+#include "bswap.h"
+
+#include "ebml.h"
+#include "matroska.h"
+
+#define NUM_PREVIEW_BUFFERS      10
+
+#define MAX_STREAMS             128
+#define MAX_FRAMES               32
+
+#define WRAP_THRESHOLD        90000
+
+typedef struct {
+  int                  track_num;
+  off_t               *pos;
+  uint64_t            *timecode;
+  int                  num_entries;
+
+} matroska_index_t;
+
+typedef struct {
+
+  demux_plugin_t       demux_plugin;
+
+  xine_stream_t       *stream;
+
+  input_plugin_t      *input;
+
+  int                  status;
+
+  ebml_parser_t       *ebml;
+
+  /* segment element */
+  ebml_elem_t          segment;
+  uint64_t             timecode_scale;
+  int                  duration;            /* in millis */
+  int                  preview_sent;
+  int                  preview_mode;
+  char                *title;
+
+  /* meta seek info */
+  int                  has_seekhead;
+  int                  seekhead_handled;
+
+  /* seek info */
+  matroska_index_t    *indexes;
+  int                  num_indexes;
+  int                  first_cluster_found;
+  int                  skip_to_timecode;
+  int                  skip_for_track;
+
+  /* tracks */
+  int                  num_tracks;
+  int                  num_video_tracks;
+  int                  num_audio_tracks;
+  int                  num_sub_tracks;
+
+  matroska_track_t    *tracks[MAX_STREAMS];
+
+  /* maintain editions, number and capacity */
+  int                  num_editions, cap_editions;
+  matroska_edition_t **editions;
+
+  /* block */
+  uint8_t             *block_data;
+  size_t               block_data_size;
+
+  /* current tracks */
+  matroska_track_t    *video_track;   /* to remove */
+  matroska_track_t    *audio_track;   /* to remove */
+  matroska_track_t    *sub_track;     /* to remove */
+  uint64_t             last_timecode;
+
+  int                  send_newpts;
+  int                  buf_flag_seek;
+
+  /* seekhead parsing */
+  int                  top_level_list_size;
+  int                  top_level_list_max_size;
+  off_t               *top_level_list;
+
+  /* event handling (chapter navigation) */
+  xine_event_queue_t  *event_queue;
+} demux_matroska_t ;
+
+typedef struct {
+
+  demux_class_t     demux_class;
+
+  /* class-wide, global variables here */
+
+  xine_t           *xine;
+
+} demux_matroska_class_t;
+
+/* "entry points" for chapter handling.
+ * The parser descends into "Chapters" elements at the _parse_ function,
+ * and editions care about cleanup internally. */
+int matroska_parse_chapters(demux_matroska_t*);
+void matroska_free_editions(demux_matroska_t*);
+
+/* Search an edition for the chapter matching a given timecode.
+ *
+ * Return: chapter index, or -1 if none is found.
+ *
+ * TODO: does not handle chapter end times yet.
+ */
+int matroska_get_chapter(demux_matroska_t*, uint64_t, matroska_edition_t**);
+
+#endif /* _DEMUX_MATROSKA_H_ */
diff -Nru xine-lib-1.1.16.4-orig/src/demuxers/Makefile.am xine-lib-1.1.16.4-lmce0/src/demuxers/Makefile.am
--- xine-lib-1.1.16.4-orig/src/demuxers/Makefile.am	2010-07-20 16:52:59.000000000 +0000
+++ xine-lib-1.1.16.4-lmce0/src/demuxers/Makefile.am	2010-07-21 12:44:33.000000000 +0000
@@ -133,7 +133,7 @@
 xineplug_dmx_nsv_la_SOURCES = demux_nsv.c
 xineplug_dmx_nsv_la_LIBADD = $(XINE_LIB)
 
-xineplug_dmx_matroska_la_SOURCES = demux_matroska.c ebml.c
+xineplug_dmx_matroska_la_SOURCES = demux_matroska.c demux_matroska-chapters.c ebml.c
 xineplug_dmx_matroska_la_LIBADD = $(XINE_LIB) $(ZLIB_LIBS)
 xineplug_dmx_matroska_la_CPPFLAGS = $(ZLIB_CPPFLAGS)
 xineplug_dmx_matroska_la_CFLAGS = $(AM_CFLAGS) -fno-strict-aliasing
diff -Nru xine-lib-1.1.16.4-orig/src/demuxers/matroska.h xine-lib-1.1.16.4-lmce0/src/demuxers/matroska.h
--- xine-lib-1.1.16.4-orig/src/demuxers/matroska.h	2010-07-20 16:52:59.000000000 +0000
+++ xine-lib-1.1.16.4-lmce0/src/demuxers/matroska.h	2010-07-21 12:34:06.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2000-2007 the xine project
+ * Copyright (C) 2000-2009 the xine project
  *
  * This file is part of xine, a free video player.
  *
@@ -16,6 +16,8 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ * Matroska EBML stream handling
  */
 #ifndef MATROSKA_H
 #define MATROSKA_H
@@ -62,6 +64,7 @@
 #define MATROSKA_ID_CL_BLOCKGROUP                 0xA0
 #define MATROSKA_ID_CL_BLOCK                      0xA1
 #define MATROSKA_ID_CL_BLOCKVIRTUAL               0xA2
+#define MATROSKA_ID_CL_SIMPLEBLOCK                0xA3
 #define MATROSKA_ID_CL_BLOCKADDITIONS             0x75A1
 #define MATROSKA_ID_CL_BLOCKMORE                  0xA6
 #define MATROSKA_ID_CL_BLOCKADDID                 0xEE
@@ -168,10 +171,16 @@
 /* Chapters */
 #define MATROSKA_ID_CHAPTERS                      0x1043A770
 #define MATROSKA_ID_CH_EDITIONENTRY               0x45B9
+#define MATROSKA_ID_CH_ED_UID                     0x45BC
+#define MATROSKA_ID_CH_ED_HIDDEN                  0x45BD
+#define MATROSKA_ID_CH_ED_DEFAULT                 0x45DB
+#define MATROSKA_ID_CH_ED_ORDERED                 0x45DD
 #define MATROSKA_ID_CH_ATOM                       0xB6
 #define MATROSKA_ID_CH_UID                        0x73C4
 #define MATROSKA_ID_CH_TIMESTART                  0x91
 #define MATROSKA_ID_CH_TIMEEND                    0x92
+#define MATROSKA_ID_CH_HIDDEN                     0x98
+#define MATROSKA_ID_CH_ENABLED                    0x4598
 #define MATROSKA_ID_CH_TRACK                      0x8F
 #define MATROSKA_ID_CH_TRACKNUMBER                0x89
 #define MATROSKA_ID_CH_DISPLAY                    0x80
@@ -182,6 +191,46 @@
 /* Tags */
 #define MATROSKA_ID_TAGS                          0x1254C367
 
+/* Chapter (used in tracks) */
+typedef struct {
+  uint64_t uid;
+  uint64_t time_start;
+  uint64_t time_end;
+  /* if not 0, the chapter could e.g. be used for skipping, but not
+   * be shown in the chapter list */
+  int hidden;
+  /* disabled chapters should be skipped during playback (using this
+   * would require parsing control blocks) */
+  int enabled;
+  /* Tracks this chapter belongs to.
+   * Remember that elements can occur in any order, so in theory the
+   * chapters could become available before the tracks do.
+   * TODO: currently unused
+   */
+  /* uint64_t* tracks; */
+  /* Chapter titles and locale information
+   * TODO: chapters can have multiple sets of those, i.e. several tuples
+   *  (title, language, country). The current implementation picks from
+   *  those by the following rules:
+   *   1) remember the first element
+   *   2) overwrite with an element where language=="eng"
+   */
+  char* title;
+  char* language;
+  char* country;
+} matroska_chapter_t;
+
+/* Edition */
+typedef struct {
+  uint64_t uid;
+  unsigned int hidden;
+  unsigned int is_default;
+  unsigned int ordered;
+
+  int num_chapters, cap_chapters;
+  matroska_chapter_t** chapters;
+} matroska_edition_t;
+
 /* Matroska Track */
 typedef struct {
   int                      flag_interlaced;
@@ -213,7 +262,8 @@
 typedef struct matroska_track_s matroska_track_t;
 struct matroska_track_s {
   int                      track_num;
-  
+  uint64_t uid;
+
   uint32_t                 track_type;
   uint64_t                 default_duration;
   char                    *language;
@@ -222,7 +272,7 @@
   uint32_t                 codec_private_len;
   int                      default_flag;
   uint32_t                 compress_algo;
-  
+
   uint32_t                 buf_type;
   fifo_buffer_t           *fifo;
 
