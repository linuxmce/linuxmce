#! /bin/sh /usr/share/dpatch/dpatch-run
## 23_pad2keys.dpatch by Mario Limonciello <superm1@ubuntu.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: For pad2keys imon support (LP: #153184).

@DPATCH@
diff -urNad lirc~/drivers/lirc_imon/lirc_imon.c lirc/drivers/lirc_imon/lirc_imon.c
--- lirc~/drivers/lirc_imon/lirc_imon.c	2008-06-04 01:13:05.000000000 -0500
+++ lirc/drivers/lirc_imon/lirc_imon.c	2008-06-04 01:29:54.000000000 -0500
@@ -73,9 +73,9 @@
 
 
 #define MOD_AUTHOR	"Venky Raju <dev@venky.ws>"
-#define MOD_DESC	"Driver for Soundgraph iMON MultiMedia IR/VFD"
+#define MOD_DESC	"Driver for Soundgraph iMON MultiMedia IR/VFD w/imon pad2keys patch"
 #define MOD_NAME	"lirc_imon"
-#define MOD_VERSION	"0.3"
+#define MOD_VERSION	"0.3p2k"
 
 #define VFD_MINOR_BASE	144	/* Same as LCD */
 #define DEVFS_MODE	(S_IFCHR | S_IRUSR | S_IWUSR | \
@@ -91,6 +91,7 @@
 #define	TRUE		1
 #define FALSE		0
 
+#define CURSOR_LIMIT	16
 
 /* ------------------------------------------------------------
  *		     P R O T O T Y P E S
@@ -177,6 +178,10 @@
 		atomic_t busy;			/* write in progress */
 		int status;			/* status of tx completion */
 	} tx;
+
+	int key_x;
+	int key_y;
+	int last_count;				/* number of times pressed   */
 };
 
 #define LOCK_CONTEXT	down(&context->sem)
@@ -248,6 +253,9 @@
 static int is_lcd; /* If LIRC_IMON_LCD not defined, default to non-LCD */
 #endif
 
+/* pad2keys module parameter. pad2keys patch active? */
+static int pad2keys_active = 0;
+
 #if !defined(KERNEL_2_5)
 
 #define MAX_DEVICES	4	/* In case there's more than one iMON device */
@@ -271,6 +279,7 @@
 
 MODULE_AUTHOR(MOD_AUTHOR);
 MODULE_DESCRIPTION(MOD_DESC);
+MODULE_VERSION(MOD_VERSION);  /* MBr: was missing */
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(usb, imon_usb_id_table);
 
@@ -286,6 +295,8 @@
 MODULE_PARM_DESC(is_lcd, "The device is an LCD: 0=no (it's a VFD), "
 		 "1=yes (default:no)");
 #endif
+module_param (pad2keys_active, int, 0);
+MODULE_PARM_DESC (pad2keys_active, "pad2keys patch active: 0=no, 1=yes (default: no)");
 
 static inline void delete_context(struct imon_context *context)
 {
@@ -766,6 +777,11 @@
 	context->rx.initial_space = 1;
 	context->rx.prev_bit = 0;
 
+	/* init pad context for pad2keys */
+	context ->key_x = 0;
+	context ->key_y = 0;
+	context ->last_count = 0;
+ 
 	usb_fill_int_urb(context->rx_urb, context->dev,
 		usb_rcvintpipe(context->dev,
 				context->rx_endpoint->bEndpointAddress),
@@ -915,6 +931,94 @@
 
 	if (context->ir_onboard_decode) {
 		/* The signals have been decoded onboard the iMON controller */
+                
+                if (pad2keys_active)
+                {
+                   /* imon pad2keys patch
+                    *
+                    * make PAD and mouse buttons available for use with VDR,
+                    * based on pad-mouse-emu patch from venky's forum
+                    *
+                    * last change: M.Brakemeier 2007-10-14
+                    *
+                    * generated PAD key codes:
+                    * Mouse_N                  0x690281B7
+                    * Mouse_S                  0x688291B7
+                    * Mouse_W                  0x6A8281B7
+                    * Mouse_E                  0x688A81B7
+                    *
+                    * mouse buttons (non-synthetic):
+                    * MouseRightClick          0x688481B7
+                    * MouseLeftClick           0x688301B7
+                    */
+                    if((buf[0] & 0x40) &&
+                        !(buf[1] & 0x01 || buf[1] >> 2 & 0x01))
+                    {
+                        int rel_x = (buf[1] & 0x08) | (buf[1] & 0x10) >> 2 | (buf[1] & 0x20) >> 4 | (buf[1] & 0x40) >> 6;
+                        int rel_y = (buf[2] & 0x08) | (buf[2] & 0x10) >> 2 | (buf[2] & 0x20) >> 4 | (buf[2] & 0x40) >> 6;
+        
+                        if(buf[0] & 0x02)
+                            rel_x |= ~0x10+1;
+                        if(buf[0] & 0x01)
+                            rel_y |= ~0x10+1;
+        
+                        /* keyboard direction key emulation */
+                        if( context->last_count > 32 )
+                        {  /* Hopefully eliminate drift*/
+                            context->last_count=0;
+                            context->key_y=0;
+                            context->key_x=0;
+                        }
+                        context->last_count++;
+        
+                        /* limit decoded events */
+                        if(abs(context->key_x) > CURSOR_LIMIT || abs(context->key_y) > CURSOR_LIMIT )
+                        {
+                            if(abs(context->key_y ) > abs(context->key_x))
+                            { /* mouse s/n */
+                                if(context->key_y > 0 && rel_y > 0)
+                                { /* mouse s */
+                                    buf[0] = 0x68;
+                                    buf[1] = 0x82;
+                                    buf[2] = 0x91;
+                                }
+                                else if(context->key_y < 0 && rel_y < 0)
+                                { /* mouse n */
+                                    buf[0] = 0x69;
+                                    buf[1] = 0x02;
+                                    buf[2] = 0x81;
+                                }
+                            }
+                            else
+                            { /* mouse e/w*/
+                                if(context->key_x > 0 && rel_x > 0 )
+                                { /* mouse e */
+                                    buf[0] = 0x68;
+                                    buf[1] = 0x8A;
+                                    buf[2] = 0x81;
+                                }
+                                else if(context->key_x < 0 && rel_x < 0  )
+                                { /* mouse w */
+                                    buf[0] = 0x6A;
+                                    buf[1] = 0x82;
+                                    buf[2] = 0x81;
+                                }
+                            }
+                        }
+                        else
+                        {
+                            context->key_x += rel_x;
+                            context->key_y += rel_y;
+        
+                            return; /* discard those key codes */
+                        }
+                    }
+                    /* a key was pressed, reset count */
+                    context->key_x = 0;
+                    context->key_y = 0;
+                    context->last_count = 0;
+                }
+                
 		lirc_buffer_write_1(context->plugin->rbuf, buf);
 		wake_up(&context->plugin->rbuf->wait_poll);
 		return;
