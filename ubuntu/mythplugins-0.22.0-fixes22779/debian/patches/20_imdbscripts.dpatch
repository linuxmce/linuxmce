#! /bin/sh /usr/share/dpatch/dpatch-run
## 20_imdbscripts.dpatch by  <jean-yves@avenard.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad mythplugins~/mythvideo/mythvideo/scripts/fetch_poster.py mythplugins/mythvideo/mythvideo/scripts/fetch_poster.py
--- mythplugins~/mythvideo/mythvideo/scripts/fetch_poster.py	2009-05-10 16:14:01.000000000 +1000
+++ mythplugins/mythvideo/mythvideo/scripts/fetch_poster.py	2009-06-20 23:16:11.000000000 +1000
@@ -46,6 +46,39 @@
 http://www.pythonware.com/products/pil/"""
 	imaging_library = False
 
+#Number of default IMDb retry
+import time
+defaultretries=3
+
+def functionretry(func, arg1, arg2=None, retries=None):
+	global defaultretries
+	
+	if retries == None:
+		retries = defaultretries
+	
+	attempts = 0
+	stop = False
+	while (not stop):
+		try:
+			if arg2:
+				result = func(arg1, arg2)
+			else:
+				result = func(arg1)				
+			stop = True
+		except:
+			result = None
+		if not stop:
+			attempts += 1
+			if attempts > retries:
+				stop = True
+			if attempts <= retries:
+				print 'Failed to retrieve data, retry in 5s'
+				time.sleep(5)
+			
+	if attempts > retries:
+		print 'Error retrieving data : No more attempts'
+	return result
+
 class PosterImage:
 	"""
 	Holds a single poster image.
@@ -104,13 +137,14 @@
 		max_results = 4
 		images = []
 		
-		for url in poster_urls:
-			image_url = self.find_poster_image_url(url)
-			if image_url is not None:
-				images.append(self.download_image(image_url, ".jpg"))
-				results += 1
-			if results >= max_results:
-				break
+		if poster_urls:
+			for url in poster_urls:
+				image_url = self.find_poster_image_url(url)
+				if image_url is not None:
+					images.append(self.download_image(image_url, ".jpg"))
+					results += 1
+				if results >= max_results:
+					break
 		return images
 				
 	def find_poster_image_url(self, poster_page_url):
@@ -196,7 +230,7 @@
 			return [self.download_image(poster_url, extension)]
 		return []
 			
-def find_best_posters(title, count=1, accept_horizontal=False, imdb_id=None):
+def find_best_posters(title, count=1, accept_horizontal=False, imdb_id=None, retries=None):
 		
 	fetchers = [MoviePosterPosterFetcher(), IMDbPosterFetcher()]
 	#fetchers = [IMDbPosterFetcher()]	
@@ -218,12 +252,13 @@
 			break
 		
 	for fetcher in fetchers:
-		new_posters = fetcher.fetch(title, imdb_id)
-		for poster in new_posters:
-			if not accept_horizontal and not poster.is_vertical():
-				os.remove(poster.file_name)
-				continue
-			posters.append(poster)
+		new_posters = functionretry(fetcher.fetch, title, arg2=imdb_id, retries=retries)
+		if new_posters:
+			for poster in new_posters:
+				if not accept_horizontal and not poster.is_vertical():
+					os.remove(poster.file_name)
+					continue
+				posters.append(poster)
 		
 	def size_cmp(a, b):
 		return cmp(a.pixels(), b.pixels())
@@ -237,7 +272,7 @@
 	return posters[0:count]
 		
 def main():
-	
+	global defaultretries
 	
 	p = optparse.OptionParser()
 	p.add_option('--number', '-n', action="store", type="int", default=1,
@@ -247,15 +282,23 @@
 	p.add_option('--poster_search', '-P', metavar='IMDB_ID', default=None, dest="imdb_id",
 		help="Displays a list of URL's to movie posters.  The lines are "\
 		"ranked by descending value. For MythVideo.")		
+	p.add_option('--retry', '-t', action="store", type="int", dest="retries",default=3,
+		help="Number of retries, 0 means no retry [default 3]")
 		
 	options, arguments = p.parse_args()
 	
+	defaultretries = options.retries
+
 	title = ""
 	if len(arguments) != 1:
 		if options.imdb_id:
 			# TODO: Fetch the title from IMDb.
-			metadata = imdbpy.metadata_search(options.imdb_id)
-			title = imdbpy.parse_meta(metadata, "Title")
+			metadata = functionretry(imdbpy.metadata_search,options.imdb_id)
+			if metadata:
+				title = imdbpy.parse_meta(metadata, "Title")
+			else:
+				print "Error can't retrieve title from IMDb"
+				sys.exit(1)				
 		else:
 			print "Please give a video title as argument."
 			sys.exit(1)				
@@ -263,7 +306,7 @@
 		title = arguments[0]
 		
 	posters = find_best_posters(title, options.number, options.all,
-				imdb_id=options.imdb_id)	
+				imdb_id=options.imdb_id, retries=defaultretries)	
 	
 	if options.imdb_id is not None:
 		for poster in posters:
@@ -276,4 +319,4 @@
 		
 if __name__ == '__main__':
 	main()		
-	
\ No newline at end of file
+	
diff -urNad mythplugins~/mythvideo/mythvideo/scripts/find_meta.py mythplugins/mythvideo/mythvideo/scripts/find_meta.py
--- mythplugins~/mythvideo/mythvideo/scripts/find_meta.py	2009-05-10 16:14:01.000000000 +1000
+++ mythplugins/mythvideo/mythvideo/scripts/find_meta.py	2009-06-20 23:16:11.000000000 +1000
@@ -87,7 +87,7 @@
 # Create the *.metadata files.
 metafiles = False
 
-videoExtensions = ["avi", "mpg", "wmv", "mkv"]
+videoExtensions = ["avi", "mpg", "wmv", "mkv", "mp4"]
 
 # The file name for storing metadata for videos that occupy the whole
 # directory and might consist of multiple video files for the same
@@ -102,6 +102,39 @@
 # MythTV settings table).
 poster_dir = "./"
 
+#Number of default IMDb retry
+import time
+defaultretries=3
+
+def functionretry(func, arg1, arg2=None, retries=None):
+	global defaultretries
+	
+	if retries == None:
+		retries = defaultretries
+	
+	attempts = 0
+	stop = False
+	while (not stop):
+		try:
+			if arg2:
+				result = func(arg1, arg2)
+			else:
+				result = func(arg1)				
+			stop = True
+		except:
+			result = None
+		if not stop:
+			attempts += 1
+			if attempts > retries:
+				stop = True
+			if attempts <= retries:
+				print_verbose ('Failed to retrieve data, retry in 5s')
+				time.sleep(5)
+			
+	if attempts > retries:
+		print_verbose ('Error retrieving data : No more attempts')
+	return result
+
 def print_verbose(string):
 	global verbose
 	if verbose:
@@ -153,6 +186,11 @@
 			lowest_cutpoint = pos
 
 	title = title[0:lowest_cutpoint]
+	# Remove trailing year in the form of "name [year]" or "name (year)" if any
+	m = re.compile(r"(.*)([\(\[]([0-9]+)[\]\)])$")
+	found = m.match(title.strip())
+	if found:
+		title = found.group(1)
 	return title.strip()
 
 def parse_meta(variable, oldvalue, emptyvalue="", meta=""):
@@ -347,6 +385,17 @@
 					title = aka_title + " (" + title + ")"
 					print_verbose("Found AKA: %s" % title)
 				break
+			# For IMDbPY >= 3.9
+			# Grill Point::(International: English title)
+			# Catastrofi d'amore::(Italy) [it]
+			akaRegexp = ".+::\(.+\) \[%s\].*" % aka_language
+			m = re.match(akaRegexp, aka)
+			if m is not None:
+				aka_title = aka.split("::")[0]
+				if aka_title != title:
+					title = aka_title + " (" + title + ")"
+					print_verbose("Found AKA: %s" % title)
+				break
 
 	if disc is not None:
 		title += " [disc" + unicode(disc) + "]"
@@ -400,12 +449,46 @@
 	if genrestring is not None and len(genrestring) > 0:
 		genres = genrestring.split(",")
 
+	#Always set category to "Unknown", until we can identify what it really is
+	category = mythvideo.getGenreId("Unknown")
 	if len(genres) < 1:
 		print_verbose("No genres.")
-		category = mythvideo.getGenreId("Unknown")
 	else:
-		# Only one genre supported?
-		category = mythvideo.getGenreId(genres[0])
+		#Remove previous genres
+		mythvideo.cleanGenres(intid)
+		#Set all the genres
+		for genre in genres:
+			mythvideo.setGenres(genre.strip(), intid)
+
+	countrystring = parse_metadata('Countries', "", "")
+	countries = []
+	if countrystring is not None and len(countrystring) > 0:
+		countries = countrystring.split(",")
+
+	#Always set category to "Unknown", until we can identify what it really is
+	if len(countries) < 1:
+		print_verbose("No countries.")
+	else:
+		#Remove previous genres
+		mythvideo.cleanCountry(intid)
+		#Set all the countries
+		for country in countries:
+			mythvideo.setCountry(country.strip(), intid)
+
+	caststring = parse_metadata('Cast', "", "")
+	cast = []
+	if caststring is not None and len(caststring) > 0:
+		cast = caststring.split(",")
+
+	#Always set category to "Unknown", until we can identify what it really is
+	if len(cast) < 1:
+		print_verbose("No cast.")
+	else:
+		#Remove previous cast
+		mythvideo.cleanCast(intid)
+		#Set all the cast
+		for actor in cast:
+			mythvideo.setCast(actor.strip(), intid)
 
 	if coverfile == None:
 		coverfile = "No cover"
@@ -427,6 +510,7 @@
 	otherwise returns the base name of the poster image file.
 	"""
 	global poster_dir,overwrite
+	global defaultretries
 	image_extensions = ["png", "jpg", "bmp"]
 
 	poster_files = []
@@ -436,7 +520,7 @@
 	if len(poster_files) == 0 or overwrite:
 		# Try to fetch the poster image from the web.
 		posters = fetch_poster.find_best_posters(\
-			title, count=1, accept_horizontal=True, imdb_id=imdb_id)
+			title, count=1, accept_horizontal=True, imdb_id=imdb_id,retries=defaultretries)
 
 		if len(posters) == 0:
 			return None
@@ -528,7 +612,8 @@
 
 		print_verbose("Title search '%s'" % title)
 
-		candidates = imdbpy.title_search(title)
+		candidates = functionretry(imdbpy.title_search, title)
+			
 		if candidates is None or len(candidates) == 0:
 			# TODO: Try with the dirname
 			pass
@@ -560,7 +645,7 @@
 
 	print_verbose("Querying IMDb for meta data for ID %s..." % imdb_id)
 	try:
-		meta = imdbpy.fetch_metadata(imdb_id)
+		meta = functionretry(imdbpy.fetch_metadata,imdb_id)
 		if meta is not None:
 			if meta.series_episode:
 				title, season, episode = imdbpy.detect_series_title(title)
@@ -708,7 +793,7 @@
 		metadata = load_metadata_file(metadata_target)
 
 	if imdb_id is not None:
-		meta = imdbpy.fetch_metadata(imdb_id)
+		meta = functionretry(imdbpy.fetch_metadata,imdb_id)
 		if meta.series_episode:
 			fileName = os.path.basename(pathName)
 			t, season, episode = imdbpy.detect_series_title(fileName)
@@ -734,7 +819,8 @@
 		return
 
 	if imdb_id is not None:
-		metadata = imdbpy.metadata_search(imdb_id)
+		metadata = functionretry(imdbpy.metadata_search,imdb_id)
+
 		if metadata is not None:
 			metadata += "IMDb:%s" % imdb_id + "\n"
 			save_metadata(dirName, dirName + "/video.metadata", metadata)
@@ -815,6 +901,7 @@
 	global verbose, overwrite, interactive, recursive, dbimport
 	global import_from_files, metafiles, poster_dir, poster_search
 	global aka_language
+	global defaultretries
 
 	usage = "usage: %prog [options] videopath1 [videopath2 videopath3...]"
 
@@ -831,7 +918,7 @@
 		help="Traverse sub directories of the given directory recursively.")
 
 	p.add_option('--no_dbimport', '-n', action="store_true", default=False,
-		help="Do not import metadata directly to MythDB.")
+		help="Do not import	 metadata directly to MythDB.")
 	p.add_option('--fromfiles', '-f', action="store_true", default=False,
 		help="Import data to MythDB from .metadata files if found. Requires -d.")
 	p.add_option('--metafiles', '-m', action="store_true", default=False,
@@ -848,6 +935,8 @@
 		default=None,
 		help="Add the title name in the given country (two letter code, e.g., 'fi') "\
 		"to the movie title.")
+	p.add_option('--retry', '-t', action="store", type="int", dest="retries",default=3,
+		help="Number of retries, 0 means no retry [default 3]")
 
 	options, arguments = p.parse_args()
 
@@ -865,6 +954,8 @@
 	prune = options.prune
 	poster_search = not options.skip_poster_search
 	aka_language = options.lang_code
+	
+	defaultretries = options.retries
 
 	if not (metafiles or dbimport):
 		print "You must define writing to either MythDB import (-d) or metadata files (-m)."
diff -urNad mythplugins~/mythvideo/mythvideo/scripts/imdbpy.py mythplugins/mythvideo/mythvideo/scripts/imdbpy.py
--- mythplugins~/mythvideo/mythvideo/scripts/imdbpy.py	2009-05-10 16:14:01.000000000 +1000
+++ mythplugins/mythvideo/mythvideo/scripts/imdbpy.py	2009-06-20 23:16:11.000000000 +1000
@@ -159,10 +159,10 @@
 	movies = []
 	for m in sorted_movies:
 		try:
-			movies.append([imdb_access.get_imdbID(m), m['title'], int(m['year'])])
+			item = [imdb_access.get_imdbID(m), m['title'], int(m['year'])]
 		except KeyError:
-			movies.append([imdb_access.get_imdbID(m), m['title'], 1901])
-		movies.append([imdb_access.get_imdbID(m), m['title'], int(m['year'])])
+			item = [imdb_access.get_imdbID(m), m['title'], 1901]
+		movies.append(item)
 	return movies
 
 def find_poster_url(imdb_id):
@@ -327,7 +327,15 @@
 		shortest_found = None
 		#print "%d plots found" % len(plots)
 		for plot in plots:
-			text = plot.split("::")[1]
+			#IMDbPY 3.9 doesn't order the content of plot like earlier version of IMDbPY.
+			# IMDB 3.6 is : plot_content::author
+			# IMDB 3.9 is : author::plot_content
+			#So we assume that should one side longer than the other, it's actually where the description is
+			splitvalue = plot.split("::")
+			if len(splitvalue[0]) > len(splitvalue[1]):
+				text = splitvalue[0]
+			else:
+				text = splitvalue[1]
 			if shortest_found == None or len(text) < len(shortest_found):
 				shortest_found = text
 		metadata.plot = shortest_found
@@ -397,8 +405,9 @@
 
 	if options.movie_search is not None:
 		results = title_search(options.movie_search.decode("utf8"))
-		for result in results:
-			print "%s:%s (%d)" % (result[0], result[1], result[2])
+		if results:
+			for result in results:
+				print "%s:%s (%d)" % (result[0], result[1], result[2])
 	elif options.poster_search is not None:
 		poster_search(options.poster_search)
 	elif options.metadata_search is not None:
