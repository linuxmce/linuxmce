#include "qorbiterwindow.h"
#include "OrbiterData.h"
#include <QDebug>
#include <Gen_Devices/AllCommandsRequests.h>
#include <Command_Impl.h>

#include "DCE/Logger.h"
#include "ServerLogger.h"
#include "SerializeClass/SerializeClass.h"
#include "PlutoUtils/ProcessUtils.h"
#include "PlutoUtils/FileUtils.h"
#include "PlutoUtils/StringUtils.h"
#include "PlutoUtils/Other.h"
#include "DCERouter.h"


using namespace DCE;

// You can override this block if you don't want the app to reload in the event of a problem
extern void (*g_pDeadlockHandler)(PlutoLock *pPlutoLock);
extern void (*g_pSocketCrashHandler)(Socket *pSocket);
extern Command_Impl *g_pCommand_Impl;
void DeadlockHandler(PlutoLock *pPlutoLock)
{
        // This isn't graceful, but for the moment in the event of a deadlock we'll just kill everything and force a reload
        if( g_pCommand_Impl )
        {
                LoggerWrapper::GetInstance()->Write(LV_CRITICAL,"Deadlock problem.  %d  Going to reload and quit",g_pCommand_Impl->m_dwPK_Device);
                g_pCommand_Impl->OnReload();
        }
}
void SocketCrashHandler(Socket *pSocket)
{
        // This isn't graceful, but for the moment in the event of a socket crash we'll just kill everything and force a reload
        if( g_pCommand_Impl )
        {
                LoggerWrapper::GetInstance()->Write(LV_CRITICAL,"Socket problem. %d  Going to reload and quit",g_pCommand_Impl->m_dwPK_Device);
                g_pCommand_Impl->OnReload();
        }
}
void Plugin_DeadlockHandler(PlutoLock *pPlutoLock)
{
        // This isn't graceful, but for the moment in the event of a deadlock we'll just kill everything and force a reload
        if( g_pCommand_Impl && g_pCommand_Impl->m_pRouter )
        {
                LoggerWrapper::GetInstance()->Write(LV_CRITICAL,"Plugin Deadlock problem.  %d Going to reload",g_pCommand_Impl->m_dwPK_Device);
                g_pCommand_Impl->m_pRouter->CrashWithinPlugin(g_pCommand_Impl->m_dwPK_Device);
        }
}
void Plugin_SocketCrashHandler(Socket *pSocket)
{
        if( g_pCommand_Impl && g_pCommand_Impl->m_pRouter )
        {
                LoggerWrapper::GetInstance()->Write(LV_CRITICAL,"Plugin Socket problem.  %d",g_pCommand_Impl->m_dwPK_Device);
                // g_pCommand_Impl->m_pRouter->CrashWithinPlugin(g_pCommand_Impl->m_dwPK_Device);  // Don't reload plugins since sockets can fail
        }
}
//<-dceag-incl-e->

extern "C" {
        int IsRuntimePlugin()
        {
                // If you want this plug-in to be able to register and be used even if it is not in the Device table, set this to true.
                // Then the Router will scan for all .so or .dll files, and if found they will be registered with a temporary device number
                bool bIsRuntimePlugin=false;
                if( bIsRuntimePlugin )
                        return qOrbiter::PK_DeviceTemplate_get_static();
                else
                        return 0;
        }
}


//<-dceag-plug-b->
extern "C" {
        class Command_Impl *RegisterAsPlugIn(class Router *pRouter,int PK_Device,Logger *pPlutoLogger)
        {
                LoggerWrapper::SetInstance(pPlutoLogger);
                LoggerWrapper::GetInstance()->Write(LV_STATUS, "Device: %d loaded as plug-in",PK_Device);

                qOrbiter *pqOrbiter = new qOrbiter(PK_Device, "localhost",true,false,pRouter);
                if( pqOrbiter->m_bQuit_get()|| !pqOrbiter->GetConfig() )
                {
                        delete pqOrbiter;
                        return NULL;
                }
                else
                {
                        g_pCommand_Impl=pqOrbiter;
                        g_pDeadlockHandler=Plugin_DeadlockHandler;
                        g_pSocketCrashHandler=Plugin_SocketCrashHandler;
                }
                return pqOrbiter;
        }
}
//<-dceag-plug-e->


qOrbiterWindow::qOrbiterWindow(QWidget *parent) :
    QMainWindow(parent)
{
    /*
    this block creates the orbiter ui window from a QDeclarativeView
    qOrbiterWindow is based on QMainWindow, we then load a child object, our UI into it and set it as the central widget,
    effectively making it the ui window. The main window then takes on the characteristics of the qml app/ ui
    and we the can pass DCE objects too it.
     */

    QDeclarativeView *qorbiterUI= new QDeclarativeView(this);
    qorbiterUI->rootContext()->setContextProperty("currentDateTime", QDateTime::currentDateTime());

    qorbiterUI->setSource(QUrl::fromLocalFile("qml/skins/scheme/classic/Main.qml"));
    qorbiterUI->height();


    this->setCentralWidget(qorbiterUI);
    s_RouterIP="dcerouter";


    qorbiterUI->show();


}
/*
  Note, this function is why the function at the top of the file exists. It is essentially the hacked up
  main.cpp that is auto generated by DCEGen. What I've done here is to take relevant parts of the loop and
  incorporate them into the QT side of things allowing for my objects to have only one parent and to correlate
  the UI variable that is passed in between both.
  */

bool qOrbiterWindow::setupLmce(int PK_Device, string sRouterIP, bool, bool bLocalMode)
{
    pqOrbiter = new DCE::qOrbiter(PK_Device, sRouterIP, true,bLocalMode);


    if ( pqOrbiter->GetConfig() && pqOrbiter->Connect(pqOrbiter->PK_DeviceTemplate_get()) )
    {
            qDebug() << "Device Connect";
            g_pCommand_Impl=pqOrbiter;
            g_pDeadlockHandler=DeadlockHandler;
            g_pSocketCrashHandler=SocketCrashHandler;
            LoggerWrapper::GetInstance()->Write(LV_STATUS, "Connect OK");
            /*
              we get various variable here that we will need later. I store them in the qt object so it
              can pass them along without extra issues and so they can easily be passed to qml objects that
              are templated in
             */

            pqOrbiter->CreateChildren();
            /*
              this line ties the class variable in the dceGenerated code to the qt ui code
              this is how the two threads (dce and qt) communicate with each other and make it possible to connect
              qt GUI (qml or qobject based) signals to DCE slots and vice versa!
            */
            pqOrbiter->UI = this;

            /*
              here is where we setup orbiter variables that are going to be used.
             */
            if ( getConf(PK_Device))
            {
                qDebug () << "Config Recieved, starting";
                if (refreshUI())
                 {
                 return true;
                 }
                else
                 {
                     qDebug() << "Gui could not setup!" ;
                     return false;
                 }
            }
           else
            {
                return 0;
            }



          /*  i dont know what this does, but since orbter should not be local, it is commented out but not removed.
            if( bLocalMode )
                    pqOrbiter->RunLocalMode();
            else
            {
                    if(pqOrbiter->m_RequestHandlerThread)
                            pthread_join(pqOrbiter->m_RequestHandlerThread, NULL);  // This function will return when the device is shutting down

            }
            g_pDeadlockHandler=NULL;
            g_pSocketCrashHandler=NULL; */


    }
    else
    {
            bAppError = true;
            if( pqOrbiter->m_pEvent && pqOrbiter->m_pEvent->m_pClientSocket && pqOrbiter->m_pEvent->m_pClientSocket->m_eLastError==ClientSocket::cs_err_CannotConnect )
            {
                    bAppError = false;
                    bReload = false;
                    LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "No Router.  Will abort");
                    qDebug() << "No Router, Aborting";
                    return false;
            }
            else
                    LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Connect() Failed");
            qDebug() << "Connect Failed";
    }

    if( pqOrbiter->m_bReload )
            bReload=true;
    delete pqOrbiter;

}

bool qOrbiterWindow::refreshUI()
{


   return true;
}

void qOrbiterWindow::sendMessage(QString Qmsg)
{

}

bool qOrbiterWindow::OrbiterGen()
{
    DCE::CMD_Orbiter_Registered CMD_Orbiter_Registered(iPK_Device, iOrbiterPluginID, "1" ,iPK_User, StringUtils::itos(1), iFK_Room, pData, iSize);
    // CMD_Orbiter_Registered_Cat(iPK_Device, m_pOrbiterCat ,true, BL_DirectSiblings , string ("1"), iPK_User, sEntertainArea, (int)1, pData, iSize);
 /*
    if (!SendCommand (CMD_Orbiter_Registered))
    {

        return false;
    }
    else
    {
 return true;
    }
    */

}

bool qOrbiterWindow::getConf(int pPK_Device)
{
    qDebug() << "Getting Configuration" ;
    iPK_Device = long(pPK_Device);
    iOrbiterPluginID = 9;
    iSize = 0;
    m_pOrbiterCat = 5;
    iFK_Room=1;
    sEntertainArea = "1";
   iPK_User= pqOrbiter->GetConfig();
   s_onOFF = "1";
   qDebug() << "PK_Device No:" << iPK_Device;
    qDebug() << "User: " << iPK_User;
    //qDebug() << "EA: " << QString::fromStdString(sEntertainArea);
    qDebug() << "Room: " << iFK_Room;
    //qDebug() << "On/OFF:" << qPrintable(s_onOFF);

    return true;

    }



